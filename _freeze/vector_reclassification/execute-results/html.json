{
  "hash": "4c949eb9d587e7b7747567230feee284",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"재분류\"\nauthor: Sang-Il Lee\ndate-modified: last-modified\nnumber-sections: true\nformat: \n  html: \n    toc: true\ncode-link: true\ncode-copy: true\nlightbox: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n\n## 준비\n\n필수적인 패키지를 불러온다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(tmap)\nlibrary(spdep)\n```\n:::\n\n\n서울과 관련된 데이터를 불러온다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_gu <- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\", options = \"ENCODING=CP949\")\nseoul_dong <- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\", options = \"ENCODING=CP949\")\nseoul_sido <- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\", options = \"ENCODING=CP949\")\n```\n:::\n\n\n## 합역 Spatial Aggregation\n\n### 무작위 합역 프로세스\n\n다음과 같은 함수를 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nutd.spatial.random.aggregation <- function (nhbr, m.region)\n{\n\n  # purpose: Generating a swm (gal format) of a spatial random aggregation from a binary swm of a polygon layer \n  # Arguments:\n  #   nhbr: a swm (gal formal) of an input polygon layer\n  #   m.region: the target number of polygons \n  # Fuction called:\n  #   utd.rank.out (from Monghyeon)\n\n##### First part: Extracting the an ggregation info (will be stored in sra.res) ragarding which areal units are aggregated to any seed areal unit\n\n# Randomly select a set of seed units (m.region)\n\tn <- max(nhbr[,1])\n\tseed.num <- sample(1:n, m.region)\n# Define two final data frames; the length of sra.res will increase, while the length of nhbr.res will decrease\n\tsra.res <- data.frame(seed.num, seed.num)\n\tnhbr.res <- nhbr\n# Delete entries in nhbr.res related to the seed units\n\tfor (i in 1:m.region)\n\t{\n\t\ta <- seed.num[i]\n\t\tnhbr.res <- nhbr.res[!nhbr.res[,2]==a,]\n\t}\n# Delete entries in sra.res and add entries in sra.res while looping\n\trepeat\n\t{\n\t\tfor (j in 1:m.region)\n\t\t{\n\t\t\tbb <- seed.num[j]\n\t\t\tcol.set <- vector()\n\t\t\tnhbr.id <- sra.res[,2][sra.res[,1]==bb]\n\t\t\tfor (dd in 1:length(nhbr.id))\n\t\t\t{\n\t\t\t\tnhbr.id.i <- nhbr.res[,2][nhbr.res[,1]==nhbr.id[dd]]\n\t\t\t\tcol.set <- c(col.set, nhbr.id.i)\n\t\t\t}\n\t\t\tif (length(col.set)!=0)\n\t\t\t{\n\t\t\t\tcol.selected <- sample(c(unique(col.set), bb), 1)\n\t\t\t\tif (col.selected!=bb)\n\t\t\t\t{\n\t\t\t\t\tsra.res <- rbind(sra.res, c(bb, col.selected))\n\t\t\t\t\tnhbr.res <- nhbr.res[!nhbr.res[,2]==col.selected,]\n\t\t\t\t}\n\t\t\t}\n\t\tif (length(nhbr.res[,1])==0) break\n\t\t}\n\t\tif (length(nhbr.res[,1])==0) break\n\t}\t\n# Obtain the final sra.res\n\tcolnames(sra.res) <- c(\"seed.id\", \"agg.id\")\n\tsra.res <- sra.res[order(sra.res$seed.id, sra.res$agg.id),]\n\n##### Second part: Constructing a swm on the basis of the aggregation info (will be stored in new.swm.1)\n\tfor (kk in 1:m.region)\n\t{\n\t\tnhbr.id.new <- sra.res[,2][sra.res[,1]==seed.num[kk]]\n\t\tnhbr.new.num <- length(nhbr.id.new)\n\t\tif (nhbr.new.num==0) {next}\n\t\tnew.nhbr.vec <- vector()\n\t\tfor (mm in 1:nhbr.new.num)\n\t\t{\n\t\t\tnhbr.id.old <- nhbr[,1][nhbr[,2]==nhbr.id.new[mm]]\n\t\t\tnhbr.old.num <- length(nhbr.id.old)\n\t\t\tif (nhbr.old.num==0) {next}\n\t\t\tfor (nn in 1:nhbr.old.num)\n\t\t\t{\n\t\t\t\tnew.nhbr.id <- sra.res[,1][sra.res[,2]==nhbr.id.old[nn]]\n\t\t\t\tnew.nhbr.vec <- c(new.nhbr.vec, new.nhbr.id)\n\t\t\t}\n\t\t}\n\t\tnew.nhbr.vec <- unique(new.nhbr.vec)\n\t\tlength.vec <- length(new.nhbr.vec)\n\t\tif (kk==1)\n\t\t\t{new.nhbr.res <- data.frame(row.id=rep(seed.num[kk], length.vec), col.id=new.nhbr.vec)}\n\t\telse \n\t\t\t{new.nhbr.res <- rbind(new.nhbr.res, cbind(row.id=rep(seed.num[kk], length.vec), col.id=new.nhbr.vec))}\n\t}\n\tnew.nhbr.res <- new.nhbr.res[!new.nhbr.res[,1]==new.nhbr.res[,2],]\n\tnew.nhbr.res <- cbind(new.nhbr.res, weights=rep(1,length(new.nhbr.res[,1])))\n\tnew.nhbr.res <- new.nhbr.res[order(new.nhbr.res$row.id, new.nhbr.res$col.id),]\n\n##### Third part: Updating the new swm with new IDs (will be stored in new.swm.2)\n\tutd.rank.out <- function(a.vec)\n\t{\n\t\ta.vec <- as.vector(a.vec)\n\t\tA <- as.data.frame(cbind(1:length(a.vec),a.vec))\n\t\tcolnames(A) <- c(\"id\", \"value\")\n\t\tB <- as.data.frame(cbind(unique(a.vec), rank(unique(a.vec))))\n\t\tcolnames(B) <- c(\"value\", \"rank\")\n\t\tres <- merge(A, B, by=\"value\")\n\t\tres[order(res$id),]$rank\n\t}\n\t\n\tnew.new.nhbr.res.1 <- as.vector(utd.rank.out(new.nhbr.res[,1]))\n\tnew.new.nhbr.res.2 <- as.vector(utd.rank.out(new.nhbr.res[,2]))\n\tnew.new.nhbr.res <- data.frame(row.id=new.new.nhbr.res.1, col.id=new.new.nhbr.res.2, weights=rep(1,length(new.nhbr.res[,1])))\n\tnew.new.nhbr.res <- new.new.nhbr.res[order(new.new.nhbr.res$row.id, new.new.nhbr.res$col.id),]\n\n\tcolnames(new.nhbr.res) <- c(\"from\", \"to\", \"weights\")\n\tcolnames(new.new.nhbr.res) <- c(\"from\", \"to\", \"weights\")\n\t\n\tall.res <- list(sra=sra.res, new.swm.1=new.nhbr.res, new.swm.2=new.new.nhbr.res)\n}\n```\n:::\n\n\n서울시의 426개 동을 25개로 RSA하는 한 가지 경우를 해 본다. 최종 결과로 합역의 인덱스 정보가 산출된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_dong_nb <- poly2nb(seoul_dong, queen=FALSE)\nseoul_dong_sw <- nb2listw(seoul_dong_nb, style=\"B\")\nseoul_dong_sn <- listw2sn(seoul_dong_sw)\n\nseoul_sra_25_1 <- utd.spatial.random.aggregation(seoul_dong_sn, 25)\nseoul_sra_25_1 <- seoul_sra_25_1$sra\n```\n:::\n\n\n위의 결과를 바탕으로 합역을 진행한다. 우선 seoul_dong에 일련번호를 생성한다. 이것을 공통키로 사용할 것이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_dong <- seoul_dong |> \n  mutate(\n    id = row_number()\n  )\n```\n:::\n\n\n조인한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_dong_1 <- seoul_dong |> \n  left_join(seoul_sra_25_1, join_by(id == agg.id))\n```\n:::\n\n\n합역한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_dong_sra_25_1 <- seoul_dong_1 |> \n  group_by(seed.id) |> \n  summarize(\n    geometry = st_union(geometry),\n    .groups = \"drop\"\n  )\n```\n:::\n\n\n지도를 작성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_gu) + tm_polygons(col = \"SGG1_NM\", border.col = NULL, legend.show = FALSE) +\n  tm_shape(seoul_dong_sra_25_1) + tm_borders(lwd = 1.5, col = \"gray20\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](vector_reclassification_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n두 번째 합역을 시행한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_sra_25_2 <- utd.spatial.random.aggregation(seoul_dong_sn, 25)\nseoul_sra_25_2 <- seoul_sra_25_2$sra\n\nseoul_dong_2 <- seoul_dong |> \n  left_join(seoul_sra_25_2, join_by(id == agg.id))\n\nseoul_dong_sra_25_2 <- seoul_dong_2 |> \n  group_by(seed.id) |> \n  summarize(\n    geometry = st_union(geometry),\n    .groups = \"drop\"\n  )\n```\n:::\n\n\n두 번째 지도를 작성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_gu) + tm_polygons(col = \"SGG1_NM\", border.col = NULL, legend.show = FALSE) +\n  tm_shape(seoul_dong_sra_25_2) + tm_borders(lwd = 1.5, col = \"gray20\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](vector_reclassification_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n세 번째 합역을 시행한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_sra_25_3 <- utd.spatial.random.aggregation(seoul_dong_sn, 25)\nseoul_sra_25_3 <- seoul_sra_25_3$sra\n\nseoul_dong_3 <- seoul_dong |> \n  left_join(seoul_sra_25_3, join_by(id == agg.id))\n\nseoul_dong_sra_25_3 <- seoul_dong_3 |> \n  group_by(seed.id) |> \n  summarize(\n    geometry = st_union(geometry), \n    .groups = \"drop\"\n  )\n```\n:::\n\n\n세 번째 지도를 작성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_gu) + tm_polygons(col = \"SGG1_NM\", border.col = NULL, legend.show = FALSE) +\n  tm_shape(seoul_dong_sra_25_3) + tm_borders(lwd = 1.5, col = \"gray20\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](vector_reclassification_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n네 번째 합역을 시행한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_dong_nb <- poly2nb(seoul_dong, queen=FALSE)\nseoul_dong_sw <- nb2listw(seoul_dong_nb, style=\"B\")\nseoul_dong_sn <- listw2sn(seoul_dong_sw)\n\nseoul_sra_25_4 <- utd.spatial.random.aggregation(seoul_dong_sn, 25)\nseoul_sra_25_4 <- seoul_sra_25_4$sra\n\nseoul_dong_4 <- seoul_dong |> \n  left_join(seoul_sra_25_4, join_by(id == agg.id))\n\nseoul_dong_sra_25_4 <- seoul_dong_4 |> \n  group_by(seed.id) |> \n  summarize(\n    geometry = st_union(geometry), \n    .groups = \"drop\"\n  )\n```\n:::\n\n\n네 번째 지도를 작성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_gu) + tm_polygons(col = \"SGG1_NM\", border.col = NULL, legend.show = FALSE) +\n  tm_shape(seoul_dong_sra_25_4) + tm_borders(lwd = 1.5, col = \"gray20\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](vector_reclassification_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n레퍼런스 지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_dong) + tm_polygons(col = \"SGG1_NM\", legend.show = FALSE) +\n  tm_shape(seoul_gu) + tm_polygons(alpha = 0, lwd = 1.5, border.col = \"gray20\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](vector_reclassification_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n### 목적함수 합역 프로세스\n\nChatGPT의 도움을 받아 목적함수 합역 프로세스를 시도해 본다. 필수 패키지를 설치한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(spdep)\nlibrary(GenSA)\nlibrary(readxl)\n```\n:::\n\n\n전국 2020년 센서스용 읍면동 데이터를 불러와 인구 데이터와 조인한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nEMD_2020 <- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2020_Census_Adj/EMD_2020_Census.shp\", options = \"ENCODING=CP949\")\n\nPop_SDGGEMD_2020 <- read_excel(\"D:/My R/Korea Census Data Manipulation/1 Population Basic/DM_ADJ_Census_2020.xlsx\", sheet = 1)\n\nEMD_2020 <- EMD_2020 |> \n  mutate(\n    EMD_ID = as.numeric(EMD_ID)\n  )\n\nEMD_2020_pop <- EMD_2020 |> \n  left_join(\n    Pop_SDGGEMD_2020, join_by(EMD_ID == Code)\n  )\n```\n:::\n\n\n서울만 골라낸다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_2020_pop <- EMD_2020_pop |> \n  filter(\n    SD_NM == \"서울특별시\"\n  )\n```\n:::\n\n\n인접성 행렬을 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb <- poly2nb(seoul_2020_pop)\nlistw <- nb2listw(nb)\n```\n:::\n\n\n최적화를 실행한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(123)\n\n# 목적함수: 인구 균등화 + 인접성 제약 조건 반영\nobjective_function <- function(partition) {\n  # 각 구역별로 인구 합계를 계산\n  zones <- split(seoul_2020_pop$pop_t, partition)\n  zone_totals <- sapply(zones, sum)\n  \n  # 인접성 위반 횟수 계산\n  penalty <- 0\n  for (i in 1:length(nb)) {\n    neighbors <- nb[[i]]  # i번 동의 이웃 동들\n    if (any(partition[i] != partition[neighbors])) {\n      penalty <- penalty + 1  # 인접한 동이 다른 구역에 있으면 패널티 증가\n    }\n  }\n  \n  # 인구 표준편차 + 인접성 위반 패널티를 함께 고려\n  result <- sd(zone_totals) + penalty * 10000  # 패널티 가중치 조절 가능\n  # print(result)\n  return(result)\n}\n\n# 3. 시뮬레이티드 어닐링 적용\nN <- 10\ninitial_partition <- as.numeric(sample(1:N, nrow(seoul_2020_pop), replace = TRUE))  # 초기 구역 설정을 numeric 타입으로 변환\nresult <- GenSA(par = initial_partition, fn = objective_function, lower = rep(1, nrow(seoul_2020_pop)), upper = rep(N, nrow(seoul_2020_pop)))\n\n# 결과 출력\nresult$par <- round(result$par)\nwrite_rds(result, \"optimal_zone_1.rds\")\n# seoul_2020_pop$zone <- result$par  # 최적화된 구역 할당 결과\n```\n:::\n\n\n결과를 확인한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptimal_res <- read_rds(\"optimal_zone_1.rds\")\nseoul_2020_pop$zone <- optimal_res$par\n```\n:::\n\n\n결과를 바탕으로 지오메트리를 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_zone_10 <- seoul_2020_pop |> \n  group_by(zone) |> \n  summarize(\n    geometry = st_union(geometry), \n    pop_total = sum(pop_t),\n    .groups = 'drop'\n  )\nseoul_zone_10$zone <- as.character(seoul_zone_10$zone)\n```\n:::\n\n\n지도를 생성한다. 그런데 결과는 썩 만족스럽지 않다. 연접성 요구가 거의 지켜지지 않고 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntm_shape(seoul_zone_10) + tm_polygons(col = \"zone\", style = \"cat\")\n```\n\n::: {.cell-output-display}\n![](vector_reclassification_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n",
    "supporting": [
      "vector_reclassification_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}