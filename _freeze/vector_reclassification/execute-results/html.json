{
  "hash": "2e330d2af1d57cce63843d092e8e67ff",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"재분류\"\nauthor: Sang-Il Lee\ndate-modified: last-modified\nnumber-sections: true\nformat: \n  html: \n    toc: true\ncode-link: true\ncode-copy: true\nlightbox: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n\n## 준비\n\n필수적인 패키지를 불러온다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(tmap)\nlibrary(spdep)\n```\n:::\n\n\n서울과 관련된 데이터를 불러온다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_gu <- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\", options = \"ENCODING=CP949\")\nseoul_dong <- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\", options = \"ENCODING=CP949\")\nseoul_sido <- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\", options = \"ENCODING=CP949\")\n```\n:::\n\n\n## 합역 Spatial Aggregation\n\n### 무작위 합역 프로세스\n\n다음과 같은 함수를 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nutd.spatial.random.aggregation <- function (nhbr, m.region)\n{\n\n  # purpose: Generating a swm (gal format) of a spatial random aggregation from a binary swm of a polygon layer \n  # Arguments:\n  #   nhbr: a swm (gal formal) of an input polygon layer\n  #   m.region: the target number of polygons \n  # Fuction called:\n  #   utd.rank.out (from Monghyeon)\n\n##### First part: Extracting the an ggregation info (will be stored in sra.res) ragarding which areal units are aggregated to any seed areal unit\n\n# Randomly select a set of seed units (m.region)\n\tn <- max(nhbr[,1])\n\tseed.num <- sample(1:n, m.region)\n# Define two final data frames; the length of sra.res will increase, while the length of nhbr.res will decrease\n\tsra.res <- data.frame(seed.num, seed.num)\n\tnhbr.res <- nhbr\n# Delete entries in nhbr.res related to the seed units\n\tfor (i in 1:m.region)\n\t{\n\t\ta <- seed.num[i]\n\t\tnhbr.res <- nhbr.res[!nhbr.res[,2]==a,]\n\t}\n# Delete entries in sra.res and add entries in sra.res while looping\n\trepeat\n\t{\n\t\tfor (j in 1:m.region)\n\t\t{\n\t\t\tbb <- seed.num[j]\n\t\t\tcol.set <- vector()\n\t\t\tnhbr.id <- sra.res[,2][sra.res[,1]==bb]\n\t\t\tfor (dd in 1:length(nhbr.id))\n\t\t\t{\n\t\t\t\tnhbr.id.i <- nhbr.res[,2][nhbr.res[,1]==nhbr.id[dd]]\n\t\t\t\tcol.set <- c(col.set, nhbr.id.i)\n\t\t\t}\n\t\t\tif (length(col.set)!=0)\n\t\t\t{\n\t\t\t\tcol.selected <- sample(c(unique(col.set), bb), 1)\n\t\t\t\tif (col.selected!=bb)\n\t\t\t\t{\n\t\t\t\t\tsra.res <- rbind(sra.res, c(bb, col.selected))\n\t\t\t\t\tnhbr.res <- nhbr.res[!nhbr.res[,2]==col.selected,]\n\t\t\t\t}\n\t\t\t}\n\t\tif (length(nhbr.res[,1])==0) break\n\t\t}\n\t\tif (length(nhbr.res[,1])==0) break\n\t}\t\n# Obtain the final sra.res\n\tcolnames(sra.res) <- c(\"seed.id\", \"agg.id\")\n\tsra.res <- sra.res[order(sra.res$seed.id, sra.res$agg.id),]\n\n##### Second part: Constructing a swm on the basis of the aggregation info (will be stored in new.swm.1)\n\tfor (kk in 1:m.region)\n\t{\n\t\tnhbr.id.new <- sra.res[,2][sra.res[,1]==seed.num[kk]]\n\t\tnhbr.new.num <- length(nhbr.id.new)\n\t\tif (nhbr.new.num==0) {next}\n\t\tnew.nhbr.vec <- vector()\n\t\tfor (mm in 1:nhbr.new.num)\n\t\t{\n\t\t\tnhbr.id.old <- nhbr[,1][nhbr[,2]==nhbr.id.new[mm]]\n\t\t\tnhbr.old.num <- length(nhbr.id.old)\n\t\t\tif (nhbr.old.num==0) {next}\n\t\t\tfor (nn in 1:nhbr.old.num)\n\t\t\t{\n\t\t\t\tnew.nhbr.id <- sra.res[,1][sra.res[,2]==nhbr.id.old[nn]]\n\t\t\t\tnew.nhbr.vec <- c(new.nhbr.vec, new.nhbr.id)\n\t\t\t}\n\t\t}\n\t\tnew.nhbr.vec <- unique(new.nhbr.vec)\n\t\tlength.vec <- length(new.nhbr.vec)\n\t\tif (kk==1)\n\t\t\t{new.nhbr.res <- data.frame(row.id=rep(seed.num[kk], length.vec), col.id=new.nhbr.vec)}\n\t\telse \n\t\t\t{new.nhbr.res <- rbind(new.nhbr.res, cbind(row.id=rep(seed.num[kk], length.vec), col.id=new.nhbr.vec))}\n\t}\n\tnew.nhbr.res <- new.nhbr.res[!new.nhbr.res[,1]==new.nhbr.res[,2],]\n\tnew.nhbr.res <- cbind(new.nhbr.res, weights=rep(1,length(new.nhbr.res[,1])))\n\tnew.nhbr.res <- new.nhbr.res[order(new.nhbr.res$row.id, new.nhbr.res$col.id),]\n\n##### Third part: Updating the new swm with new IDs (will be stored in new.swm.2)\n\tutd.rank.out <- function(a.vec)\n\t{\n\t\ta.vec <- as.vector(a.vec)\n\t\tA <- as.data.frame(cbind(1:length(a.vec),a.vec))\n\t\tcolnames(A) <- c(\"id\", \"value\")\n\t\tB <- as.data.frame(cbind(unique(a.vec), rank(unique(a.vec))))\n\t\tcolnames(B) <- c(\"value\", \"rank\")\n\t\tres <- merge(A, B, by=\"value\")\n\t\tres[order(res$id),]$rank\n\t}\n\t\n\tnew.new.nhbr.res.1 <- as.vector(utd.rank.out(new.nhbr.res[,1]))\n\tnew.new.nhbr.res.2 <- as.vector(utd.rank.out(new.nhbr.res[,2]))\n\tnew.new.nhbr.res <- data.frame(row.id=new.new.nhbr.res.1, col.id=new.new.nhbr.res.2, weights=rep(1,length(new.nhbr.res[,1])))\n\tnew.new.nhbr.res <- new.new.nhbr.res[order(new.new.nhbr.res$row.id, new.new.nhbr.res$col.id),]\n\n\tcolnames(new.nhbr.res) <- c(\"from\", \"to\", \"weights\")\n\tcolnames(new.new.nhbr.res) <- c(\"from\", \"to\", \"weights\")\n\t\n\tall.res <- list(sra=sra.res, new.swm.1=new.nhbr.res, new.swm.2=new.new.nhbr.res)\n}\n```\n:::\n\n\n서울시의 426개 동을 25개로 RSA하는 한 가지 경우를 해 본다. 최종 결과로 합역의 인덱스 정보가 산출된다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_dong_nb <- poly2nb(seoul_dong, queen=FALSE)\nseoul_dong_sw <- nb2listw(seoul_dong_nb, style=\"B\")\nseoul_dong_sn <- listw2sn(seoul_dong_sw)\n\nseoul_sra_25_1 <- utd.spatial.random.aggregation(seoul_dong_sn, 25)\nseoul_sra_25_1 <- seoul_sra_25_1$sra\n```\n:::\n\n\n위의 결과를 바탕으로 합역을 진행한다. 우선 seoul_dong에 일련번호를 생성한다. 이것을 공통키로 사용할 것이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_dong <- seoul_dong |> \n  mutate(\n    id = row_number()\n  )\n```\n:::\n\n\n조인한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_dong_1 <- seoul_dong |> \n  left_join(seoul_sra_25_1, join_by(id == agg.id))\n```\n:::\n\n\n합역한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_dong_sra_25_1 <- seoul_dong_1 |> \n  group_by(seed.id) |> \n  mutate(\n    geometry = st_union(geometry)\n  )\nqtm(seoul_dong_sra_25_1)\n```\n\n::: {.cell-output-display}\n![](vector_reclassification_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\n지도를 작성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_gu) + tm_polygons(col = \"SGG1_NM\", border.col = NULL, legend.show = FALSE) +\n  tm_shape(seoul_dong_sra_25_1) + tm_borders(lwd = 1.5, col = \"gray20\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](vector_reclassification_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n두 번째 합역을 시행한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_sra_25_2 <- utd.spatial.random.aggregation(seoul_dong_sn, 25)\nseoul_sra_25_2 <- seoul_sra_25_2$sra\n\nseoul_dong_2 <- seoul_dong |> \n  left_join(seoul_sra_25_2, join_by(id == agg.id))\n\nseoul_dong_sra_25_2 <- seoul_dong_2 |> \n  group_by(seed.id) |> \n  mutate(\n    geometry = st_union(geometry)\n  )\nqtm(seoul_dong_sra_25_2)\n```\n\n::: {.cell-output-display}\n![](vector_reclassification_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n두 번째 지도를 작성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_gu) + tm_polygons(col = \"SGG1_NM\", border.col = NULL, legend.show = FALSE) +\n  tm_shape(seoul_dong_sra_25_2) + tm_borders(lwd = 1.5, col = \"gray20\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](vector_reclassification_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n세 번째 합역을 시행한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_sra_25_3 <- utd.spatial.random.aggregation(seoul_dong_sn, 25)\nseoul_sra_25_3 <- seoul_sra_25_3$sra\n\nseoul_dong_3 <- seoul_dong |> \n  left_join(seoul_sra_25_3, join_by(id == agg.id))\n\nseoul_dong_sra_25_3 <- seoul_dong_3 |> \n  group_by(seed.id) |> \n  mutate(\n    geometry = st_union(geometry)\n  )\nqtm(seoul_dong_sra_25_3)\n```\n\n::: {.cell-output-display}\n![](vector_reclassification_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n세 번째 지도를 작성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_gu) + tm_polygons(col = \"SGG1_NM\", border.col = NULL, legend.show = FALSE) +\n  tm_shape(seoul_dong_sra_25_3) + tm_borders(lwd = 1.5, col = \"gray20\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](vector_reclassification_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n네 번째 합역을 시행한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_dong_nb <- poly2nb(seoul_dong, queen=FALSE)\nseoul_dong_sw <- nb2listw(seoul_dong_nb, style=\"B\")\nseoul_dong_sn <- listw2sn(seoul_dong_sw)\n\nseoul_sra_25_4 <- utd.spatial.random.aggregation(seoul_dong_sn, 25)\nseoul_sra_25_4 <- seoul_sra_25_4$sra\n\nseoul_dong_4 <- seoul_dong |> \n  left_join(seoul_sra_25_4, join_by(id == agg.id))\n\nseoul_dong_sra_25_4 <- seoul_dong_4 |> \n  group_by(seed.id) |> \n  mutate(\n    geometry = st_union(geometry)\n  )\nqtm(seoul_dong_sra_25_4)\n```\n\n::: {.cell-output-display}\n![](vector_reclassification_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n\n네 번째 지도를 작성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_gu) + tm_polygons(col = \"SGG1_NM\", border.col = NULL, legend.show = FALSE) +\n  tm_shape(seoul_dong_sra_25_4) + tm_borders(lwd = 1.5, col = \"gray20\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](vector_reclassification_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n레퍼런스 지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_dong) + tm_polygons(col = \"SGG1_NM\", legend.show = FALSE) +\n  tm_shape(seoul_gu) + tm_polygons(alpha = 0, lwd = 1.5, border.col = \"gray20\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](vector_reclassification_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "vector_reclassification_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}