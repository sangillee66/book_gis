{
  "hash": "36f1059e2d556563fcfd796fa776cf73",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"네트워크 분석\"\nauthor: Sang-Il Lee\ndate-modified: last-modified\nnumber-sections: true\nformat: \n  html: \n    toc: true\ncode-link: true\ncode-copy: true\nlightbox: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n\n## 준비\n\n필수적인 패키지를 설치한다. 네트워크 분석에서는 특히 [`sfnetworks`](https://luukvdmeer.github.io/sfnetworks/) 패키지를 기본으로 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(sfnetworks)\nlibrary(sf)\nlibrary(tmap)\n```\n:::\n\n\n서울의 행정구역 경계 파일을 불러온다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul <- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\")\nseoul_gu <- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\")\nseoul_dong <- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\")\n```\n:::\n\n\n서울의 소방서 위치를 불러온다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_sobang <- st_read(\"D:/My R/Vector Data Manipulation Korea/Seoul_Data_Plaza/sobang_station_seoul.shp\", options = \"ENCODING=CP949\")\n```\n:::\n\n\n서울시 도로망 데이터를 불러온다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_sn <- st_read(\"D:/My R/Vector Data Manipulation Korea/Korea_Transport_Database/seoul_link.shp\", options = \"ENCODING=CP949\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\noptions:        ENCODING=CP949 \nReading layer `seoul_link' from data source \n  `D:\\My R\\Vector Data Manipulation Korea\\Korea_Transport_Database\\seoul_link.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 33664 features and 37 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 935297 ymin: 1936908 xmax: 971990.4 ymax: 1966117\nProjected CRS: KGD2002 / Unified CS\n```\n\n\n:::\n\n```{.r .cell-code}\nseoul_sn <- seoul_sn |> \n  st_cast(\"LINESTRING\") # 반드시 수행해야 함. 차이가 뭘까? 위는 MULTILINESTRING임.\n```\n:::\n\n\n서울시 도로망을 sfn 객체로 만든다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_sfn <- seoul_sn |> \n  as_sfnetwork(directed = FALSE)\n```\n:::\n\n\n## 네트워크 거리 매트릭스\n\n#### 유클리드 거리 매트릭스\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist_matrix_eucl <- seoul_sobang |> \n  st_distance()\n```\n:::\n\n\n#### 네트워크 거리 매트릭스\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist_matrix_network <- seoul_sfn |> \n  st_network_cost(from = seoul_sobang, to = seoul_sobang, direction = \"all\")\n```\n:::\n\n\n## 최단 네트워크 경로\n\n각 소방서에서 종로소방서로 가는 최단 네트워크 경로를 구한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\njongro_st <- seoul_sobang |> \n  filter(\n    Name == \"종로소방서\"\n  )\nsobang_network_paths_sfn <- seoul_sfn |> \n  st_network_paths(from = jongro_st, to = seoul_sobang)\n```\n:::\n\n\n경로를 라인으로 표현하기 위해서는 `sobang_network_paths_sfn` 객체를 해부해야 한다. 함수를 작성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# snu_paths_generator <- function(net, paths_sfn, dest.point, id.var){\n#   line.list <- list()\n#   destID <- vector()\n#   n <- nrow(paths_sfn)\n#   for (i in 1:n){\n#     path.index.i <- unlist(slice(paths_sfn, i)$edge_paths)\n#     path.i <- net[path.index.i, ]\n#     line.list[[i]] <- path.i\n#     destID <-  c(destID, rep(dest.point[[id.var]][i], length(path.index.i)))\n#   }\n#   final.line <- do.call(rbind, line.list)\n#   final.line <- cbind(final.line, destID)\n# }\n\nsnu_paths_generator <- function(net, paths_sfn, dest.point, id.var){\n  result <- paths_sfn |> \n    mutate(\n      path.index = map(edge_paths, ~net[unlist(.x), ]),\n      destID = map(1:n(), ~dest.point[[id.var]][.x])\n    )\n  final.line <- result |> \n    unnest(cols = c(path.index, destID)) |>\n    bind_cols() |> st_as_sf()  \n  return(final.line)\n}\n```\n:::\n\n\n이 함수를 활용하여 최단 경로에 대한 라인을 추출한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsobang_network_paths_sfn_lines <- seoul_sn |>  \n  snu_paths_generator(sobang_network_paths_sfn, seoul_sobang, \"Name\") #여기서는 seoul_sn 사용\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray70\") +\n  tm_shape(sobang_network_paths_sfn_lines) + tm_lines(lwd = 4)+\n  tm_shape(seoul_sobang) + tm_dots(col = \"Name\", size = 1, legend.show = FALSE) + \n  tm_shape(jongro_st) + tm_dots(col = \"black\", size = 1) + \n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Shortest Network Paths to Jongro Station\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_network_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n## 최적배달경로분석\n\n여기서는 `TSP` 패키지를 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(TSP)\n\ndist_matrix_network <- seoul_sfn |> \n  st_network_cost(from = seoul_sobang, to = seoul_sobang)\nsobang_index <- seoul_sobang |> \n  st_nearest_feature(seoul_sfn) # 가장 가까이에 있는 도로 세그먼트 index\n\n# 소방서간 최단 거리가 아니라 도로 세그먼트 간 최단 거리\ndist_matrix_network <- dist_matrix_network |> \n  as_tibble() |> \n  mutate(row_index = sobang_index) |>     \n  column_to_rownames(var = \"row_index\") |> \n  setNames(sobang_index) |> \n  as.matrix()\n\n# row.names(dist_matrix_network) <- sobang_index\n# colnames(dist_matrix_network) <- sobang_index\n\nTSP_tour <- TSP::solve_TSP(TSP(dist_matrix_network)) # TSP 문제를 해결\nTSP_tour_index <- as.numeric(names(TSP_tour))\n\nround(tour_length(TSP_tour), 0) # 전체 길이를 계산해준다. 128.851m\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 129939\n```\n\n\n:::\n\n```{.r .cell-code}\nfrom_index <- TSP_tour_index\nto_index <- c(TSP_tour_index[2:length(TSP_tour_index)], TSP_tour_index[1])\n\n# TSP_paths <- mapply(st_network_paths, from = from_index, to = to_index, MoreArgs = list(x = seoul_sfn))[\"edge_paths\", ] |> unlist(recursive = FALSE)\n\nTSP_paths <- map2(from_index, to_index, ~st_network_paths(x = seoul_sfn, from = .x, to = .y)$edge_paths) |> \n  unlist(recursive = FALSE)\n```\n:::\n\n\n경로를 라인으로 표현하기 위해서는 TSP_paths 객체를 해부해야 한다. 함수를 작성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsnu_TSP_generator <- function(net, tsp_paths, dest.point, id.var){\n  line.list <- list()\n  destID <- vector()\n  n <- length(tsp_paths)\n  for (i in 1:n){\n    path.index.i <- tsp_paths[[i]]\n    path.i <- net[path.index.i, ]\n    line.list[[i]] <- path.i\n    destID <-  c(destID, rep(dest.point[[id.var]][i], length(path.index.i)))\n  }\n  final.line <- do.call(rbind, line.list)\n  final.line <- cbind(final.line, destID)\n}\n```\n:::\n\n\n이 함수를 활용하여 TSP 경로를 추출한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTSP_paths_line <- snu_TSP_generator(seoul_sn, TSP_paths, seoul_sobang, \"Name\")\n```\n:::\n\n\n지도를 작성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray70\") +\n  tm_shape(TSP_paths_line) + tm_lines(lwd = 4)+\n  tm_shape(seoul_sobang) + tm_dots(col = \"Name\", size = 1, legend.show = FALSE) + \n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Traveling Salesman Problem Path\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_network_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n## 최근접시설물분석\n\n#### 네트워크 할당: line-to-facility\n\n도로 세그먼트에 최근린 소방서의 ID를 할당하고자 한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_sn_cent <- seoul_sn |> \n  st_centroid() # 모든 도로 세그먼트의 센트로이드 생성\n\ndist_cent_sobang <- seoul_sfn |> \n  st_network_cost(from = seoul_sn_cent, to = seoul_sobang) # 모든 도로 세그먼트의 센트로이드로부터 소방서까지의 네트워크 거리 계산\n\n# closest_cent <- seoul_sobang$Name[apply(dist_cent_sobang, 1, function(x) which(x == min(x))[1])] \n\nclosest_cent <- map_int(1:nrow(dist_cent_sobang), ~ {\n  row <- dist_cent_sobang[.x, ]\n  which(row == min(row))[1]\n  }) \n\nseoul_sn$closest <- seoul_sobang$Name[closest_cent]\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"closest\", lwd = 1, legend.col.show = FALSE) +\n  tm_shape(seoul_sobang) + tm_dots(col = \"Name\", shape = 21, border.col = \"black\", size = 1, legend.show = FALSE) + \n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Closest Facilities: Network Allocation\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_network_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n#### 포인트 할당: point-to-facility\n\n임의의 지점을 선정하고 최근린 소방서를 연결하는 일종의 스파이더 지도(spider map) 혹은 디자이어 라인 지도(desire line map) 지도를 생성한다. 우선 도로 네트워크의 센트로이드 중 임의의 지점 500개를 추출한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnetwork_sample <- seoul_sn_cent |> \n  st_sample(500, type = \"random\") |> \n  st_as_sf(crs = 5179) |> \n  st_cast(\"POINT\")\n```\n:::\n\n\n500개 지점에서 최근린 소방서를 확인한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist_sample_sobang <- seoul_sfn |>  \n  st_network_cost(from = network_sample, to = seoul_sobang)\n\n# closest_sample <- seoul_sobang[apply(dist_sample_sobang, 1, function(x) which(x == min(x))[1]), ]\n\nclosest_index <- map_int(1:nrow(dist_sample_sobang), ~ {\n  row <- dist_sample_sobang[.x, ]\n  which(row == min(row))[1]\n  }) \nclosest_sample <- seoul_sobang |> \n  slice(closest_index)\n```\n:::\n\n\n이 정보를 이용해 샘플링 포인트와 최근린 소방서를 연결하는 라인을 생성하기 위한 함수를 작성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsnu_make_linestring_from_2points <- function(source.point, target.point, target.id.var){\n  n <- nrow(source.point)\n  line.list <- list()\n  source_coord <- st_coordinates(source.point)\n  target_coord <- st_coordinates(target.point)\n  for (i in 1:n){\n    line.list[[i]] <- st_sfc(st_linestring(rbind(source_coord[i, ], target_coord[i, ]))) # st_sfc를 씌우지 않으면 에러가 남!!!\n  }\n  final.line <- do.call(rbind, line.list)\n  final.line <- st_as_sf(st_sfc(final.line, crs = st_crs(seoul))) # 매우 중요\n  final.line <- cbind(Name = target.point[[target.id.var]], final.line)\n} \n```\n:::\n\n\n이 함수를 이용해 라인을 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclosest_sample_lines <- snu_make_linestring_from_2points(network_sample, closest_sample, \"Name\")\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray80\") +\n  tm_shape(closest_sample_lines) + tm_lines(col = \"Name\", lwd = 2, legend.col.show = FALSE) + \n  tm_shape(seoul_sobang) + tm_dots(col = \"Name\", shape = 21, border.col = \"black\", size = 1, legend.show = FALSE) + \n  tm_shape(network_sample) + tm_dots(col = \"grey40\", size = 0.1) + \n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Closest Facilities: Network Allocation\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_network_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n## 서비스영역분석\n\n종로 소방서의 서비스영역을 분석한다. 서비스영역(isochrone)을 생성하기 위해 [`snNetwork`](https://jeremygelb.github.io/spNetwork/) 패키지를 활용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::install_github(\"JeremyGelb/spNetwork\")\nlibrary(spNetwork)\n```\n:::\n\n\n`calc_isochrones` 함수를 이용하여 2km, 5km, 10km 네트워크에 해당하는 서비스 영역을 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\niso_jongro <- calc_isochrones(\n  lines = seoul_sn, start_points = jongro_st, dists = c(2, 5, 10), weight = \"LENGTH\") |> \n  mutate(\n    fct_dist = fct(as.character(distance))\n  ) |> \n  arrange(\n    desc(distance)\n  )\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray\") +\n  tm_shape(iso_jongro) + tm_lines(col = \"fct_dist\", lwd = 2, title.col = \"Distance (km)\", palette = c(\"1\" = \"#005f73\", \"5\" = \"#ca6702\", \"10\" = \"#9b2226\"))+\n  tm_shape(jongro_st) + tm_dots(col = \"black\", size = 1) + \n  tm_legend(legend.position = c(0.80, 0.05)) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Service Areas: Lines\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_network_files/figure-html/unnamed-chunk-29-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n서비스 영역에 대한 폴리곤을 생성한다. 여기서는 또 다른 패키지인 `concaveman`을 활용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(concaveman)\n\niso_jongro |> \n  mutate(\n    iso_oid = str_c(point_id, distance, sep = \"_\")\n  ) -> iso_jongro\n\npolygons <- map(unique(iso_jongro$iso_oid), ~{\n  lines <- subset(iso_jongro, iso_jongro$iso_oid == .x)\n  coords <- st_coordinates(lines)\n  poly_coords <- concaveman(points = coords, concavity = 3)\n  poly <- st_polygon(list(poly_coords[, 1:2]))\n  return(poly)\n})\n\niso_sp <- st_sf(iso_oid = unique(iso_jongro$iso_oid), distance = unique(iso_jongro$distance), geometry = polygons, crs = st_crs(iso_jongro)) \n\niso_sp |> \n  mutate(\n    fct_dist = as.factor(distance)\n  ) |> \n  arrange(\n    desc(distance)\n  ) -> iso_sp\n\n# iso_jongro$iso_oid <- paste(iso_jongro$point_id, iso_jongro$distance, sep = \"_\")\n# \n# polygons <- lapply(unique(iso_jongro$iso_oid), function(oid){\n#   lines <- subset(iso_jongro, iso_jongro$iso_oid == oid)\n#   coords <- st_coordinates(lines)\n#   poly_coords <- concaveman(points = coords, concavity = 3)\n#   poly <- st_polygon(list(poly_coords[,1:2]))\n#   return(poly)\n# })\n# \n# iso_sp <- st_sf(iso_oid = unique(iso_jongro$iso_oid), distance = unique(iso_jongro$distance), geometry = polygons, crs = st_crs(iso_jongro)) \n# \n# iso_sp$fct_dist <- as.factor(iso_sp$distance)\n# iso_sp <- iso_sp[order(-1*iso_sp$distance),]\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray\") +\n  tm_shape(iso_sp) + tm_polygons(col = \"fct_dist\", title = \"Distance (km)\", palette = c(\"1\" = \"#005f73\", \"5\" = \"#ca6702\", \"10\" = \"#9b2226\"), alpha = 0.5, border.col = \"white\") +\n  tm_shape(jongro_st) + tm_dots(col = \"black\", size = 1) + \n  tm_legend(legend.position = c(0.80, 0.05)) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Service Areas: Polygons\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_network_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "sm_network_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}