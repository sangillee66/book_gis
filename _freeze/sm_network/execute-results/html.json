{
  "hash": "babb69137951a09742fe26fdb06cf300",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"네트워크 분석\"\nauthor: Sang-Il Lee\ndate-modified: last-modified\nnumber-sections: true\nformat: \n  html: \n    toc: true\ncode-link: true\ncode-copy: true\nlightbox: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n\n## 준비\n\n필수적인 패키지를 설치한다. 네트워크 분석에서는 특히 [`sfnetworks`](https://luukvdmeer.github.io/sfnetworks/) 패키지를 기본으로 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(sfnetworks)\nlibrary(sf)\nlibrary(tmap)\n```\n:::\n\n\n서울의 행정구역 경계 파일을 불러온다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul <- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\")\nseoul_gu <- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\")\nseoul_dong <- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\")\n```\n:::\n\n\n서울의 소방서 위치를 불러온다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_sobang <- st_read(\"D:/My R/Vector Data Manipulation Korea/Seoul_Data_Plaza/sobang_station_seoul.shp\", options = \"ENCODING=CP949\")\n```\n:::\n\n\n## 도로망 데이터 살펴보기\n\n서울시 도로망 데이터를 불러온다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_sn <- st_read(\"D:/My R/Vector Data Manipulation Korea/Korea_Transport_Database/seoul_link.shp\", options = \"ENCODING=CP949\")\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\noptions:        ENCODING=CP949 \nReading layer `seoul_link' from data source \n  `D:\\My R\\Vector Data Manipulation Korea\\Korea_Transport_Database\\seoul_link.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 33664 features and 37 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 935297 ymin: 1936908 xmax: 971990.4 ymax: 1966117\nProjected CRS: KGD2002 / Unified CS\n```\n\n\n:::\n\n```{.r .cell-code}\nseoul_sn <- seoul_sn |> \n  st_cast(\"LINESTRING\") # 반드시 수행해야 함. 차이가 뭘까? 위는 MULTILINESTRING임.\n```\n:::\n\n\n속성 데이터를 살펴본다. 길이를 다시 계산한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_sn |> \n  mutate(\n    NEW_LENGTH = st_length(geometry)\n  ) -> seoul_sn\n```\n:::\n\n\n`MAX_SPD`(제한 속도) 변수와 라인 세그먼트이 길이(`NEW_LENGTH`)를 사용하여 시간거리 계산을 위한 새로운 변수를 생성하고자 한다. 각 라인 세그먼트를 통과하는데 몇 분(min)이 걸리는지를 계산하여 새로운 컬럼(`COST_DIST`)을 생성하고 그것을 나중에 가중치로 사용하고자 한다. 각 라인 세그먼트를 통과하는데 몇 분(min)이 걸리는지를 계산하기 위해서는 `MAX_SPD`를 이용하여 해당 라인 세그먼트의 1m를 통과하는데 몇 분(min)이 걸리는지(`min_per_m`)를 계산한다. 그리고 나서 그 값에 라인 세그먼트의 길이(m)를 곱하면 된다. 여기에 평상시 MAX_SPD의 70만 달릴 수 있는 것으로 가정한다. 다음의 공식이 성립한다.\n\n$$\n\\text {COST_DIST}=\\text {min_per_m} \\times \\text{NEW_LENGTH} = \\frac{6}{\\text {MAX_SPD} \\times 0.7 \\times 100} \\times \\text {NEW_LENGTH}\n$$\n\n우선 MAX_SPD의 분포를 살펴본다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_sn |> \n  count(MAX_SPD)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nSimple feature collection with 12 features and 2 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 935297 ymin: 1936908 xmax: 971990.4 ymax: 1966117\nProjected CRS: KGD2002 / Unified CS\nFirst 10 features:\n   MAX_SPD     n                       geometry\n1        0 10001 MULTILINESTRING ((969846.8 ...\n2       10     6 MULTILINESTRING ((955635.8 ...\n3      100   120 MULTILINESTRING ((970456.8 ...\n4      110     3 MULTILINESTRING ((959743.7 ...\n5       20    38 MULTILINESTRING ((944882.1 ...\n6       30  6139 MULTILINESTRING ((967826.8 ...\n7       40  1945 MULTILINESTRING ((947812.7 ...\n8       50   558 MULTILINESTRING ((935381 19...\n9       60 13216 MULTILINESTRING ((968139.5 ...\n10      70   961 MULTILINESTRING ((948405 19...\n```\n\n\n:::\n:::\n\n\n총 33,715개 중 10,001개의 라인 세그먼트의 제한 속도가 0으로 되어 있다. 10인 경우도 6개, 20인 경우도 38개 이다. 제한 속도가 0, 10, 20인 경우를 모두 30으로 바꾼다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_sn |> \n  mutate(\n    NEW_MAX_SPD = if_else(\n      MAX_SPD %in% c(\"0\", \"10\", \"20\"), \"30\", MAX_SPD\n    )\n  ) -> seoul_sn\n```\n:::\n\n\n이제 COST_DIST를 계산한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_sn |> \n  mutate(\n    COST_DIST = 6 / ((as.numeric(NEW_MAX_SPD)) * 0.7 * 100) * as.numeric(NEW_LENGTH)\n  ) -> seoul_sn\n```\n:::\n\n\n서울시 도로망을 sfn 객체로 만든다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_sfn <- seoul_sn |> \n  as_sfnetwork(directed = FALSE)\n```\n:::\n\n\n## 네트워크 거리 매트릭스\n\n#### 유클리드 거리 매트릭스\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist_matrix_eucl <- seoul_sobang |> \n  st_distance()\n```\n:::\n\n\n#### 네트워크 거리 매트릭스\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist_matrix_network <- seoul_sfn |> \n  st_network_cost(from = seoul_sobang, to = seoul_sobang, direction = \"all\")\n```\n:::\n\n\n#### 시간 거리 매트릭스\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist_matrix_time <- seoul_sfn |> \n  st_network_cost(from = seoul_sobang, to = seoul_sobang, direction = \"all\", weights = \"COST_DIST\")\n```\n:::\n\n\n## 최단 네트워크 경로\n\n### 네트워크 거리의 경우\n\n각 소방서에서 종로소방서로 가는 최단 네트워크 경로를 구한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\njongro_st <- seoul_sobang |> \n  filter(\n    Name == \"종로소방서\"\n  )\nsobang_network_paths_sfn <- seoul_sfn |> \n  st_network_paths(from = jongro_st, to = seoul_sobang)\n```\n:::\n\n\n경로를 라인으로 표현하기 위해서는 `sobang_network_paths_sfn` 객체를 해부해야 한다. 함수를 작성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# snu_paths_generator <- function(net, paths_sfn, dest.point, id.var){\n#   line.list <- list()\n#   destID <- vector()\n#   n <- nrow(paths_sfn)\n#   for (i in 1:n){\n#     path.index.i <- unlist(slice(paths_sfn, i)$edge_paths)\n#     path.i <- net[path.index.i, ]\n#     line.list[[i]] <- path.i\n#     destID <-  c(destID, rep(dest.point[[id.var]][i], length(path.index.i)))\n#   }\n#   final.line <- do.call(rbind, line.list)\n#   final.line <- cbind(final.line, destID)\n# }\n\nsnu_paths_generator <- function(net, paths_sfn, dest.point, id.var){\n  result <- paths_sfn |> \n    mutate(\n      path.index = map(edge_paths, ~net[unlist(.x), ]),\n      destID = map(1:n(), ~dest.point[[id.var]][.x])\n    )\n  final.line <- result |> \n    unnest(cols = c(path.index, destID)) |>\n    bind_cols() |> st_as_sf()  \n  return(final.line)\n}\n```\n:::\n\n\n이 함수를 활용하여 최단 경로에 대한 라인을 추출한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsobang_network_paths_sfn_lines <- seoul_sn |>  \n  snu_paths_generator(sobang_network_paths_sfn, seoul_sobang, \"Name\") #여기서는 seoul_sn 사용\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray70\") +\n  tm_shape(sobang_network_paths_sfn_lines) + tm_lines(lwd = 4)+\n  tm_shape(seoul_sobang) + tm_dots(col = \"Name\", size = 1, legend.show = FALSE) + \n  tm_shape(jongro_st) + tm_dots(col = \"black\", size = 1) + \n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Shortest Network Paths to Jongro Station\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_network_files/figure-html/unnamed-chunk-16-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n### 시간 거리의 경우\n\n각 소방서에서 종로소방서로 가는 최단 시간 경로를 구한다. 가중치로 `COST_DIST`를 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsobang_network_paths_sfn_t <- seoul_sfn |> \n  st_network_paths(from = jongro_st, to = seoul_sobang, weights = \"COST_DIST\")\n```\n:::\n\n\n위와 동일한 방법으로 `sobang_network_paths_sfn_t` 객체를 해부한다\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsobang_network_paths_sfn_lines_t <- seoul_sn |>  \n  snu_paths_generator(sobang_network_paths_sfn_t, seoul_sobang, \"Name\")\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray70\") +\n  tm_shape(sobang_network_paths_sfn_lines_t) + tm_lines(lwd = 4)+\n  tm_shape(seoul_sobang) + tm_dots(col = \"Name\", size = 1, legend.show = FALSE) + \n  tm_shape(jongro_st) + tm_dots(col = \"black\", size = 1) + \n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Shortest Network Paths to Jongro Station\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_network_files/figure-html/unnamed-chunk-20-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n## 최적배달경로분석\n\n여기서는 `TSP` 패키지를 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(TSP)\n\ndist_matrix_network <- seoul_sfn |> \n  st_network_cost(from = seoul_sobang, to = seoul_sobang)\nsobang_index <- seoul_sobang |> \n  st_nearest_feature(seoul_sfn) # 가장 가까이에 있는 도로 세그먼트 index\n\n# 소방서간 최단 거리가 아니라 도로 세그먼트 간 최단 거리\ndist_matrix_network <- dist_matrix_network |> \n  as_tibble() |> \n  mutate(row_index = sobang_index) |>     \n  column_to_rownames(var = \"row_index\") |> \n  setNames(sobang_index) |> \n  as.matrix()\n\n# row.names(dist_matrix_network) <- sobang_index\n# colnames(dist_matrix_network) <- sobang_index\n\nTSP_tour <- TSP::solve_TSP(TSP(dist_matrix_network)) # TSP 문제를 해결\nTSP_tour_index <- as.numeric(names(TSP_tour))\n\nround(tour_length(TSP_tour), 0) # 전체 길이를 계산해준다. 128.851m\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 128605\n```\n\n\n:::\n\n```{.r .cell-code}\nfrom_index <- TSP_tour_index\nto_index <- c(TSP_tour_index[2:length(TSP_tour_index)], TSP_tour_index[1])\n\n# TSP_paths <- mapply(st_network_paths, from = from_index, to = to_index, MoreArgs = list(x = seoul_sfn))[\"edge_paths\", ] |> unlist(recursive = FALSE)\n\nTSP_paths <- map2(from_index, to_index, ~st_network_paths(x = seoul_sfn, from = .x, to = .y)$edge_paths) |> \n  unlist(recursive = FALSE)\n```\n:::\n\n\n경로를 라인으로 표현하기 위해서는 TSP_paths 객체를 해부해야 한다. 함수를 작성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsnu_TSP_generator <- function(net, tsp_paths, dest.point, id.var){\n  line.list <- list()\n  destID <- vector()\n  n <- length(tsp_paths)\n  for (i in 1:n){\n    path.index.i <- tsp_paths[[i]]\n    path.i <- net[path.index.i, ]\n    line.list[[i]] <- path.i\n    destID <-  c(destID, rep(dest.point[[id.var]][i], length(path.index.i)))\n  }\n  final.line <- do.call(rbind, line.list)\n  final.line <- cbind(final.line, destID)\n}\n```\n:::\n\n\n이 함수를 활용하여 TSP 경로를 추출한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nTSP_paths_line <- snu_TSP_generator(seoul_sn, TSP_paths, seoul_sobang, \"Name\")\n```\n:::\n\n\n지도를 작성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray70\") +\n  tm_shape(TSP_paths_line) + tm_lines(lwd = 4)+\n  tm_shape(seoul_sobang) + tm_dots(col = \"Name\", size = 1, legend.show = FALSE) + \n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Traveling Salesman Problem Path\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_network_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n## 최근접시설물분석\n\n#### 네트워크 할당: line-to-facility\n\n도로 세그먼트에 최근린 소방서의 ID를 할당하고자 한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_sn_cent <- seoul_sn |> \n  st_centroid() # 모든 도로 세그먼트의 센트로이드 생성\n\ndist_cent_sobang <- seoul_sfn |> \n  st_network_cost(from = seoul_sn_cent, to = seoul_sobang) # 모든 도로 세그먼트의 센트로이드로부터 소방서까지의 네트워크 거리 계산\n\n# closest_cent <- seoul_sobang$Name[apply(dist_cent_sobang, 1, function(x) which(x == min(x))[1])] \n\nclosest_cent <- map_int(1:nrow(dist_cent_sobang), ~ {\n  row <- dist_cent_sobang[.x, ]\n  which(row == min(row))[1]\n  }) \n\nseoul_sn$closest <- seoul_sobang$Name[closest_cent]\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"closest\", lwd = 1, legend.col.show = FALSE) +\n  tm_shape(seoul_sobang) + tm_dots(col = \"Name\", shape = 21, border.col = \"black\", size = 1, legend.show = FALSE) + \n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Closest Facilities: Network Allocation\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_network_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n#### 포인트 할당: point-to-facility\n\n임의의 지점을 선정하고 최근린 소방서를 연결하는 일종의 스파이더 지도(spider map) 혹은 디자이어 라인 지도(desire line map) 지도를 생성한다. 우선 도로 네트워크의 센트로이드 중 임의의 지점 500개를 추출한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnetwork_sample <- seoul_sn_cent |> \n  st_sample(500, type = \"random\") |> \n  st_as_sf(crs = 5179) |> \n  st_cast(\"POINT\")\n```\n:::\n\n\n500개 지점에서 최근린 소방서를 확인한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndist_sample_sobang <- seoul_sfn |>  \n  st_network_cost(from = network_sample, to = seoul_sobang)\n\n# closest_sample <- seoul_sobang[apply(dist_sample_sobang, 1, function(x) which(x == min(x))[1]), ]\n\nclosest_index <- map_int(1:nrow(dist_sample_sobang), ~ {\n  row <- dist_sample_sobang[.x, ]\n  which(row == min(row))[1]\n  }) \nclosest_sample <- seoul_sobang |> \n  slice(closest_index)\n```\n:::\n\n\n이 정보를 이용해 샘플링 포인트와 최근린 소방서를 연결하는 라인을 생성하기 위한 함수를 작성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# snu_make_linestring_from_2points <- function(source.point, target.point, target.id.var){\n#   n <- nrow(source.point)\n#   line.list <- list()\n#   source_coord <- st_coordinates(source.point)\n#   target_coord <- st_coordinates(target.point)\n#   for (i in 1:n){\n#     line.list[[i]] <- st_sfc(st_linestring(rbind(source_coord[i, ], target_coord[i, ]))) # st_sfc를 씌우지 않으면 에러가 남!!!\n#   }\n#   final.line <- do.call(rbind, line.list)\n#   final.line <- st_as_sf(st_sfc(final.line, crs = st_crs(seoul))) # 매우 중요\n#   final.line <- cbind(Name = target.point[[target.id.var]], final.line)\n# } \n\nsnu_make_linestring_from_2points <- function(source.point, target.point, target.id.var) {\n  source_coord <- st_coordinates(source.point)\n  target_coord <- st_coordinates(target.point)\n  line.list <- map(seq_len(nrow(source.point)), ~ st_sfc(st_linestring(rbind(source_coord[.x, ], target_coord[.x, ]))))\n  \n  final.line <- st_as_sf(do.call(c, line.list), crs = st_crs(seoul))\n  final.line <- cbind(Name = target.point[[target.id.var]], final.line)\n  return(final.line)\n}\n```\n:::\n\n\n이 함수를 이용해 라인을 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nclosest_sample_lines <- snu_make_linestring_from_2points(network_sample, closest_sample, \"Name\")\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray80\") +\n  tm_shape(closest_sample_lines) + tm_lines(col = \"Name\", lwd = 2, legend.col.show = FALSE) + \n  tm_shape(seoul_sobang) + tm_dots(col = \"Name\", shape = 21, border.col = \"black\", size = 1, legend.show = FALSE) + \n  tm_shape(network_sample) + tm_dots(col = \"grey40\", size = 0.1) + \n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Closest Facilities: Network Allocation\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_network_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n## 서비스영역분석\n\n종로 소방서의 서비스영역을 분석한다. 서비스영역(isochrone)을 생성하기 위해 [`snNetwork`](https://jeremygelb.github.io/spNetwork/) 패키지를 활용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndevtools::install_github(\"JeremyGelb/spNetwork\")\nlibrary(spNetwork)\n```\n:::\n\n\n### 네트워크 거리의 경우\n\n`calc_isochrones` 함수를 이용하여 2km, 5km, 10km 네트워크에 해당하는 서비스 영역을 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\niso_jongro <- calc_isochrones(\n  lines = seoul_sn, start_points = jongro_st, dists = c(2000, 5000, 10000), weight = \"NEW_LENGTH\") |> \n  mutate(\n    fct_dist = fct(as.character(distance / 1000))\n  ) |> \n  arrange(\n    desc(distance)\n  )\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray\") +\n  tm_shape(iso_jongro) + tm_lines(col = \"fct_dist\", lwd = 2, title.col = \"Distance (km)\", palette = c(\"1\" = \"#005f73\", \"5\" = \"#ca6702\", \"10\" = \"#9b2226\"))+\n  tm_shape(jongro_st) + tm_dots(col = \"black\", size = 1) + \n  tm_legend(legend.position = c(0.80, 0.05)) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Service Areas: Lines\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_network_files/figure-html/unnamed-chunk-38-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n서비스 영역에 대한 폴리곤을 생성한다. 여기서는 또 다른 패키지인 `concaveman`을 활용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(concaveman)\n\niso_jongro |> \n  mutate(\n    iso_oid = str_c(point_id, distance, sep = \"_\")\n  ) -> iso_jongro\n\npolygons <- map(unique(iso_jongro$iso_oid), ~{\n  lines <- subset(iso_jongro, iso_jongro$iso_oid == .x)\n  coords <- st_coordinates(lines)\n  poly_coords <- concaveman(points = coords, concavity = 3)\n  poly <- st_polygon(list(poly_coords[, 1:2]))\n  return(poly)\n})\n\niso_sp <- st_sf(iso_oid = unique(iso_jongro$iso_oid), distance = unique(iso_jongro$distance), geometry = polygons, crs = st_crs(iso_jongro)) \n\niso_sp |> \n  mutate(\n    fct_dist = as.factor(distance)\n  ) |> \n  arrange(\n    desc(distance)\n  ) -> iso_sp\n\n# iso_jongro$iso_oid <- paste(iso_jongro$point_id, iso_jongro$distance, sep = \"_\")\n# \n# polygons <- lapply(unique(iso_jongro$iso_oid), function(oid){\n#   lines <- subset(iso_jongro, iso_jongro$iso_oid == oid)\n#   coords <- st_coordinates(lines)\n#   poly_coords <- concaveman(points = coords, concavity = 3)\n#   poly <- st_polygon(list(poly_coords[,1:2]))\n#   return(poly)\n# })\n# \n# iso_sp <- st_sf(iso_oid = unique(iso_jongro$iso_oid), distance = unique(iso_jongro$distance), geometry = polygons, crs = st_crs(iso_jongro)) \n# \n# iso_sp$fct_dist <- as.factor(iso_sp$distance)\n# iso_sp <- iso_sp[order(-1*iso_sp$distance),]\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray\") +\n  tm_shape(iso_sp) + tm_polygons(col = \"fct_dist\", title = \"Distance (km)\", palette = c(\"1\" = \"#005f73\", \"5\" = \"#ca6702\", \"10\" = \"#9b2226\"), alpha = 0.5, border.col = \"white\") +\n  tm_shape(jongro_st) + tm_dots(col = \"black\", size = 1) + \n  tm_legend(legend.position = c(0.80, 0.05)) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Service Areas: Polygons\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_network_files/figure-html/unnamed-chunk-41-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n### 시간 거리의 경우\n\n`calc_isochrones` 함수를 이용하여 15분, 30분, 60분 네트워크에 해당하는 서비스 영역을 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\niso_jongro_t <- calc_isochrones(\n  lines = seoul_sn, start_points = jongro_st, dists = c(2, 5, 10), weight = \"COST_DIST\") |> \n  mutate(\n    fct_dist = fct(as.character(distance))\n  ) |> \n  arrange(\n    desc(distance)\n  )\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray\") +\n  tm_shape(iso_jongro_t) + tm_lines(col = \"fct_dist\", lwd = 2, title.col = \"Time (min)\", palette = c(\"1\" = \"#005f73\", \"5\" = \"#ca6702\", \"10\" = \"#9b2226\"))+\n  tm_shape(jongro_st) + tm_dots(col = \"black\", size = 1) + \n  tm_legend(legend.position = c(0.80, 0.05)) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Service Areas: Lines\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_network_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n서비스 영역에 대한 폴리곤을 생성한다. 여기서는 또 다른 패키지인 `concaveman`을 활용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(concaveman)\n\niso_jongro_t |> \n  mutate(\n    iso_oid = str_c(point_id, distance, sep = \"_\")\n  ) -> iso_jongro_t\n\npolygons <- map(unique(iso_jongro_t$iso_oid), ~{\n  lines <- subset(iso_jongro_t, iso_jongro_t$iso_oid == .x)\n  coords <- st_coordinates(lines)\n  poly_coords <- concaveman(points = coords, concavity = 3)\n  poly <- st_polygon(list(poly_coords[, 1:2]))\n  return(poly)\n})\n\niso_sp_t <- st_sf(iso_oid = unique(iso_jongro_t$iso_oid), distance = unique(iso_jongro_t$distance), geometry = polygons, crs = st_crs(iso_jongro_t)) \n\niso_sp_t |> \n  mutate(\n    fct_dist = as.factor(distance)\n  ) |> \n  arrange(\n    desc(distance)\n  ) -> iso_sp_t\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray\") +\n  tm_shape(iso_sp_t) + tm_polygons(col = \"fct_dist\", title = \"Time (min)\", palette = c(\"1\" = \"#005f73\", \"5\" = \"#ca6702\", \"10\" = \"#9b2226\"), alpha = 0.5, border.col = \"white\") +\n  tm_shape(jongro_st) + tm_dots(col = \"black\", size = 1) + \n  tm_legend(legend.position = c(0.80, 0.05)) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Service Areas: Polygons\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_network_files/figure-html/unnamed-chunk-47-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "sm_network_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}