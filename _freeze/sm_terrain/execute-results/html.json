{
  "hash": "521062ec34578710a7246f9c551a909b",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"지형 분석\"\nauthor: Sang-Il Lee\ndate-modified: last-modified\nnumber-sections: true\nformat: \n  html: \n    toc: true\ncode-link: true\ncode-copy: true\nlightbox: true\nexecute: \n  warning: false\n  error: false\n  freeze: auto\neditor: visual\neditor_options: \n  chunk_output_type: console\n---\n\n\n## 수치지형모델\n\n### 종류\n\n### DEM 데이터\n\n## DEM 분석\n\n### 준비\n\n필수적인 패키지를 설치한다. 래스터 분석을 위한 기본 패키지를 `terra`를 사용한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(sf)\nlibrary(tmap)\n```\n:::\n\n\n서울에 대한 SRTM 기반 DEM 데이터를 불러온다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndem_seoul <- rast(\"D:/My R/World Data Manupulation/USGS EarthExplorer/srtm_seoul.tif\")\ndem_seoul_mask <- rast(\"D:/My R/World Data Manupulation/USGS EarthExplorer/srtm_seoul_mask.tif\")\n```\n:::\n\n\n서울의 행정구역 바운더리 파일을 불러온다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul <- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\")\nseoul_gu <- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\")\nseoul_dong <- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\")\n```\n:::\n\n\n### 지형 요소의 추출\n\n#### 경사\n\n`terrain()` 함수를 이용하여 경사(slope)를 계산한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_slope <- dem_seoul_mask |> \n  terrain(v = \"slope\", neighbors = 8, unit = \"degrees\")\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_slope, raster.downsample = FALSE) + \n  tm_raster(style = \"fixed\", breaks = c(0, 5, 10, 15, 20, 25, 30, 35, Inf), palette = \"-RdYlGn\", title = \"Slope\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Slope\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_terrain_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n#### 향\n\n`terrain()` 함수를 이용하여 향(aspect)을 계산한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_aspect <- dem_seoul_mask |> \n  terrain(v = \"aspect\", neighbors = 8, unit = \"degrees\")\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\naspect_col <- c(\"#84D600\", \"#00AB44\", \"#0068C0\", \"#6C00A3\", \"#CA009C\", \"#FF5568\", \"#FFAB47\", \"#F4FA00\", \"#84D600\")\n\nmy_map <- tm_shape(seoul_aspect) + \n  tm_raster(style = \"fixed\", \n            breaks = c(0, 22.5, 67.5, 112.5, 157.5, 202.5, 247.5, 292.5, 337.5, 360), \n            labels = c(\"N\", \"NE\", \"E\", \"SE\", \"S\", \"SW\", \"W\", \"NW\", \"N\"), \n            palette = aspect_col, title = \"Aspect\", legend.is.portrait = FALSE) +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Aspect\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_terrain_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n#### TRI(Terrain Ruggedness Index)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_TRI <- dem_seoul_mask |> \n  terrain(v = \"TRI\", neighbors = 8, unit = \"degrees\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_TRI, raster.downsample = FALSE) + tm_raster(style = \"cont\", palette = \"Purples\", title = \"TRI\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: TRI\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_terrain_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\n#### TPI(Topographic Position Index)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_TPI <- dem_seoul_mask |> \n  terrain(v = \"TRI\", neighbors = 8, unit = \"degrees\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_TPI, raster.downsample = FALSE) + tm_raster(style = \"cont\", palette = \"Purples\", title = \"TPI\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: TPI\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_terrain_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\n#### Roughness\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_roughness <- dem_seoul_mask |> \n  terrain(v = \"roughness\", neighbors = 8, unit = \"degrees\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_roughness, raster.downsample = FALSE) + tm_raster(style = \"cont\", palette = \"Purples\", title = \"Roughness\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Roughness\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_terrain_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n#### Flow Direction\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_flowdir <- dem_seoul_mask |> \n  terrain(v = \"flowdir\", neighbors = 8, unit = \"degrees\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_flowdir, raster.downsample = FALSE) + tm_raster(style = \"cont\", palette = \"Purples\", title = \"Flow Direction\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Flow Direction\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_terrain_files/figure-html/unnamed-chunk-17-1.png){width=672}\n:::\n:::\n\n\n#### 곡률: 종곡률(profile curvature)\n\n곡률은 `spatialEco` 패키지를 활용하여 계산한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(spatialEco)\nseoul_curv_profile <- curvature(dem_seoul_mask, type = \"profile\")\nseoul_curv_profile <- dem_seoul_mask |> \n  curvature(type = \"profile\")\n```\n:::\n\n\n지도를 제작한다. 연속형은 별로 좋지 않을 것 같음.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_curv_profile, raster.downsample = FALSE) + tm_raster(style = \"quantile\", palette = \"BrBG\", title = \"Curvature\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Profile Curvature\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_terrain_files/figure-html/unnamed-chunk-19-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n#### 곡률: 횡곡률(plan curvature)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_curv_plan <- dem_seoul_mask |> \n  curvature(type = \"planform\")\n```\n:::\n\n\n지도를 제작한다. 연속형은 별로 좋지 않을 것으로 보인다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_curv_plan, raster.downsample = FALSE) + tm_raster(style = \"quantile\", palette = \"BrBG\", title = \"Curvature\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Plan Curvature\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_terrain_files/figure-html/unnamed-chunk-22-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n### 시각화\n\n#### 힐셰이딩(hillshading)\n\nslope와 aspect를 라디안 단위로 생성하고, `shade()` 함수에 두 개를 투입하면 힐셰이드 래스터 래이어를 얻을 수 있다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_slope_radian <- dem_seoul_mask |> \n  terrain(v = \"slope\", neighbors = 8, unit = \"radians\")\nseoul_aspect_radian <- dem_seoul_mask |> \n  terrain(v = \"aspect\", neighbors = 8, unit = \"radians\")\nseoul_hillshade <- shade(\n  seoul_slope_radian, \n  seoul_aspect_radian, angle = 45, direction = 45, normalize = TRUE\n  )\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_hillshade, raster.downsample = FALSE) + tm_raster(style = \"cont\", palette = \"-Greys\", title = \"\", legend.show = FALSE) +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Hillshading\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_terrain_files/figure-html/unnamed-chunk-25-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n#### 단면도 생성(transverse profiling)\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 두 지점을 연결하는 라인 sf 객체를 만든다.\nline_sf <- tibble(x = c(126.961091, 126.992310), y = c(37.442904, 37.660032)) |> \n  as.matrix() |> # st_linestring()은 매트릭스만 받음\n  st_linestring() |> \n  st_sfc(crs = 4326) |> \n  st_sf(geometry = _) |> # _ 표시는 직전에 만들어진 것을 인풋으로 받는다는 의미\n  st_transform(crs = 5179)\n\n# 라인 상에 적절한 간격의 포인트를 생성한다.\npoints_sf <- line_sf |> \n  st_line_sample(density = 0.1) |> # '단위 길이 당 포인트의 수'를 의미, 10m당 하나씩을 택한다는 의미.\n  st_cast(\"POINT\") |> \n  st_sf() \n\n# 래스터로부터 각 포인트에 해당하는 값을 추출한다.\nelev_profile <- dem_seoul_mask |> \n  extract(points_sf) |> \n  mutate(\n    distance = ID * 10 / 1000, # 10m 당 하나이므로 10을 곱해 거리(m)로 만들고, 1,000으로 나누어 km 단위\n    elevation = n37_e126_1arc_v3,\n    .keep = \"unused\"\n  )\n```\n:::\n\n\n단면 그래프를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# library(units)\nmy_graph <- ggplot(data = elev_profile) +\n  geom_line(aes(x = distance, y = elevation)) +\n  labs(x = \"Distance(km)\", y = \"Elevation(m)\") + \n  theme(aspect.ratio = 1/4)\nmy_graph\n```\n\n::: {.cell-output-display}\n![](sm_terrain_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n두 지점을 연결한 선이 나타나는 레퍼런스 지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_hillshade, raster.downsample = FALSE) + tm_raster(style = \"cont\", palette = \"-Greys\", title = \"\", legend.show = FALSE) +\n  tm_shape(line_sf) + tm_lines(col = \"red\", lwd = 2) +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Transverse Profiling\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_terrain_files/figure-html/unnamed-chunk-30-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n#### 컨투어링(contouring)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_contour <- dem_seoul_mask |> \n  as.contour() |> \n  st_as_sf()\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(dem_seoul_mask, raster.downsample = FALSE) + tm_raster(style = \"fixed\", breaks = c(-Inf, 50, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, Inf), palette = \"Greys\", legend.show = FALSE) +\n  tm_shape(subset(seoul_contour, level %in% c(50, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 700))) + \n  tm_iso(text = \"level\", color = \"black\", lwd = 1, size = 1, alpha = 0.7) +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Contouring\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_terrain_files/figure-html/unnamed-chunk-33-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n### 가시성(visibility) 분석\n\n#### 가시권(viewshed) 분석\n\n우선 내 연구실의 경위도 좌표를 평면직각좌표로 전환한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoints_sf <- tibble(lon = 126.955184, lat = 37.460422) |> \n  st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326) |> \n  st_transform(crs = 5179) \nst_coordinates(points_sf)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n            X       Y\n[1,] 951818.1 1940275\n```\n\n\n:::\n:::\n\n\n`terra` 패키지의 `viewshed()` 함수를 활용하여 가시권을 계산한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nseoul_viewshed <- dem_seoul_mask |> \n  viewshed(loc = c(951818.1, 1940275), \n           observer = 15, \n           output = \"yes/no\"\n  )\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_hillshade, raster.downsample = FALSE) + tm_raster(style = \"cont\", palette = \"-Greys\", title = \"\", legend.show = FALSE) +\n  tm_shape(seoul_viewshed, raster.downsample = FALSE) + tm_raster(style = \"cat\", title = \"Viewshed\", alpha = 0.5) +\n  tm_shape(points_sf) + tm_symbols(col = \"black\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Viewshed\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_terrain_files/figure-html/unnamed-chunk-37-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n\n\n#### 가시선(line-of-sight) 분석\n\n10동 옥상에서 개화산 정상을 바라봤을 때의 가시선 분석을 수행한다.\n\n우선, 옥상과 개화산 정상으로 이루어진 포인트 피처 레이어를 만든다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npoints_sf_2 <- tibble(X = c(126.955184, 126.803605), Y = c(37.460422, 37.582374)) |> \n  st_as_sf(coords = c(\"X\", \"Y\"), crs = 4326) |> \n  st_transform(crs = 5179) \n```\n:::\n\n\n다음으로, 옥상과 개화산 정상을 연결한 라인 피처 레이어를 생성한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nline_sf_1 <- tibble(X = c(126.955184, 126.803605), Y = c(37.460422, 37.582374)) |> \n  as.matrix() |> \n  st_linestring() |> \n  st_sfc(crs = 4326) |> \n  st_sf(geometry = _) |> \n  st_transform(crs = 5179)\n```\n:::\n\n\n가시선 분석은 가시권 분석이 이루어진 이상 별다른 가치가 없다. 그러나 특별한 라인 상에서 가시성이 어떻게 나타나는지를 살펴보고 싶을 수는 있다. 가시선을 생성하기 위한 시작은 당연히 가시권면에서 라인이 지나가는 부분의 레스터 셀을 선택하는 것일 것이다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlos_r <- seoul_viewshed |> \n  mask(line_sf_1)\n```\n:::\n\n\n그런데 이것은 결국 래스터이므로 선형 피처를 얻고자 하는 목적에 부합하지 않는다. 최종적으로 원하는 것은 래스터의 대각선 길이로 라인 세그먼트가 분할되어 있고, 그것의 속성으로 TRUE/FALSE 값이 들어가 있는 벡터 라인 레이어이다. `st` 패키지의 `st_segmentize()` 함수와 `st_split()` 함수를 사용한 방법을 생각해 보았지만 모두 실패하였다.\n\n그래서 `stplanr` 패키지의 `line_segment()` 함수를 사용하고자 한다. 이 함수를 사용하여 전체 라인을 적당한 숫자의 라인 세그먼트로 분할한다. 라인의 전체 길이가 대략 20km 정도이고, 셀 크기를 고려할 때 약 700개 정도이면 적절한 것으로 판단하였다. 그리고 나서 terra 패키지의 extract() 함수를 이용하여 라인 세그먼트의 viewshed 값을 가져온다. 일종의 인터폴레이션을 적용하는 것이기 때문에 함수를 지정해야 하고 이 맥락에서는 max 혹은 min이 적절할 것으로 보인다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(stplanr)\nline_segments <- line_sf_1 |> \n  line_segment(\n    n_segments = 700\n  )\nlos_line <- seoul_viewshed |> \n  extract(line_segments, fun = \"max\", bind = TRUE) |> \n  st_as_sf() |> \n  mutate(\n    Yes_No = if_else(viewshed == 1, \"TRUE\", \"FALSE\")\n  )\n```\n:::\n\n\n아래의 방법은 chatGPT 선생이 제안한 방법이다. 속도는 조근 더 빠른 것 같고, viewshed의 값을 읽는 방식이 좀 더 직접적인 것으로 보인다. 그러나 결과에 큰 차이는 없다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nextracted <- extract(seoul_viewshed, line_sf_1, cells = TRUE)\nextracted <- extracted[!is.na(extracted[, \"viewshed\"]), ]  # Filter out No (NA) cells\n\n# Step 3: Loop through adjacent points to create line segments with attributes\nsegments <- list()\nfor (i in 1:(nrow(extracted) - 1)) {\n  # Get coordinates for each pair of adjacent cells\n  coords <- xyFromCell(seoul_viewshed, extracted[c(i, i + 1), \"cell\"])\n  # Create a line segment\n  segment <- vect(coords, type=\"line\", crs=crs(seoul_viewshed))\n  # Assign Yes/No attribute (1 for Yes, NA for No) based on the first point in each pair\n  values(segment) <- data.frame(Yes_No = extracted[i, \"viewshed\"])\n  # Append to list\n  segments[[i]] <- segment\n}\n# Step 4: Combine all segments into a single SpatVector\nline_segments <- do.call(rbind, segments)\nlos_line <- st_as_sf(line_segments)\n```\n:::\n\n\n지도를 제작한다.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmy_map <- tm_shape(seoul_hillshade, raster.downsample = FALSE) + tm_raster(style = \"cont\", palette = \"-Greys\", title = \"\", legend.show = FALSE) +\n  tm_shape(los_line) + tm_lines(col = \"Yes_No\", style = \"cat\", lwd = 3, title.col = \"Seen or Not\") +\n    tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_shape(points_sf_2) + tm_symbols(col = \"gray10\", size = 1) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Line-of-Site\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n```\n\n::: {.cell-output-display}\n![](sm_terrain_files/figure-html/unnamed-chunk-44-1.png){width=672}\n:::\n:::\n\n::: {.cell}\n\n:::\n",
    "supporting": [
      "sm_terrain_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}