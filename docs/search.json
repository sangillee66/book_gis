[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "GIS",
    "section": "",
    "text": "Preface\n이것은 GIS 웹북이다.",
    "crumbs": [
      "Preface"
    ]
  },
  {
    "objectID": "first_concepts.html",
    "href": "first_concepts.html",
    "title": "\n1  GIS의 개념\n",
    "section": "",
    "text": "1.1 GIS의 근원",
    "crumbs": [
      "GIS의 개념과 적용",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>GIS의 개념</span>"
    ]
  },
  {
    "objectID": "first_concepts.html#gis의-정의",
    "href": "first_concepts.html#gis의-정의",
    "title": "\n1  GIS의 개념\n",
    "section": "\n1.2 GIS의 정의",
    "text": "1.2 GIS의 정의",
    "crumbs": [
      "GIS의 개념과 적용",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>GIS의 개념</span>"
    ]
  },
  {
    "objectID": "first_concepts.html#gis의-의미",
    "href": "first_concepts.html#gis의-의미",
    "title": "\n1  GIS의 개념\n",
    "section": "\n1.3 GIS의 의미",
    "text": "1.3 GIS의 의미\n\n1.3.1 GIS의 G\nGIS의 G는 GIS가 특별한 종류의 데이터를 다룬다는 것을 의미한다. 그 특별한 데이터는 지리적(geographic) 혹은 공간적(spatial) 혹은 지리공간적(geospatial) 데이터이다. 지리적 데이터는 비지리적 데이터와 달리 세 가지 요소를 반드시 갖추고 있어야 한다. 그 세가지는 위치(location), 속성(attributes), 공간관계(spatial relationships)이다.\n필수 패키지를 불러온다.\n\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(tmap)\n\n필수 셰이프 파일을 불러온다.\n\nsigungu1 &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/3 Generalization/2023_2Q/SIGUNGU1_2023_2Q_GEN_0030.shp\", options = \"ENCODING=CP949\")\nsido_polyline &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/3 Generalization/2023_2Q/SIDO_Polyline_2023_2Q_GEN_0030.shp\", options = \"ENCODING=CP949\")\nbbox_ulleung &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/3 Generalization/2023_2Q/BBOX_Ulleung_2023_2Q_GEN_0030.shp\", options = \"ENCODING=CP949\")\nbbox_seohae &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/3 Generalization/2023_2Q/BBOX_Seohae3_2023_2Q_GEN_0030.shp\", options = \"ENCODING=CP949\")\nseoul_gu &lt;- st_read(\n  \"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\", options = \"ENCODING=CP949\"\n  ) \nseoul_sido &lt;- st_read(\n  \"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\", options = \"ENCODING=CP949\"\n  )\n\n관악구가 표시된 시군구 지도를 제작한다.\n\ngwanak_gu &lt;- sigungu1 |&gt; \n  filter(SGG1_NM == \"관악구\")\nmy_map &lt;- tm_shape(sigungu1) + tm_polygons() +\n  tm_shape(gwanak_gu) + tm_polygons(col = \"#e41a1c\") +\n  tm_shape(sido_polyline) + tm_lines(col = \"black\", lwd = 1.5) +\n  tm_shape(bbox_ulleung) + tm_lines() +\n  tm_shape(bbox_seohae) + tm_lines() +\n  tm_layout(inner.margins = c(0.02, 0.03, 0.02, 0.04)) +\n  tm_scale_bar(breaks = seq(0, 200, 50), color.dark = \"gray60\", position = c(0.48, 0.01))\nmy_map\n\n\n\n\n\n\nFigure 1.1: 시군구 지도 상의 관악구의 위치\n\n\n\n\n관악구가 표시된 서울시 지도를 제작한다.\n\ngwanak_gu &lt;- seoul_gu |&gt; \n  filter(SGG1_NM == \"관악구\")\nmy_map &lt;- tm_shape(seoul_gu) + tm_polygons() +\n  tm_shape(gwanak_gu) + tm_borders(col = \"#e41a1c\", lwd = 3) + \n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map \n\n\n\n\n\n\nFigure 1.2: 서울시 지도 상의 관악구의 위치\n\n\n\n\n\n1.3.2 GIS의 I\n\n1.3.3 GIS의 S",
    "crumbs": [
      "GIS의 개념과 적용",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>GIS의 개념</span>"
    ]
  },
  {
    "objectID": "first_concepts.html#gis의-구성요소",
    "href": "first_concepts.html#gis의-구성요소",
    "title": "\n1  GIS의 개념\n",
    "section": "\n1.4 GIS의 구성요소",
    "text": "1.4 GIS의 구성요소",
    "crumbs": [
      "GIS의 개념과 적용",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>GIS의 개념</span>"
    ]
  },
  {
    "objectID": "first_concepts.html#gis의-역사",
    "href": "first_concepts.html#gis의-역사",
    "title": "\n1  GIS의 개념\n",
    "section": "\n1.5 GIS의 역사",
    "text": "1.5 GIS의 역사",
    "crumbs": [
      "GIS의 개념과 적용",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>GIS의 개념</span>"
    ]
  },
  {
    "objectID": "first_concepts.html#gis와-지리",
    "href": "first_concepts.html#gis와-지리",
    "title": "\n1  GIS의 개념\n",
    "section": "\n1.6 GIS와 지리",
    "text": "1.6 GIS와 지리\n\n\n\nFigure 1.1: 시군구 지도 상의 관악구의 위치\nFigure 1.2: 서울시 지도 상의 관악구의 위치",
    "crumbs": [
      "GIS의 개념과 적용",
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>GIS의 개념</span>"
    ]
  },
  {
    "objectID": "third_sdm.html",
    "href": "third_sdm.html",
    "title": "\n5  공간데이터모델\n",
    "section": "",
    "text": "5.1 정의와 개념",
    "crumbs": [
      "공간데이터모델과 GIS 데이터베이스",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>공간데이터모델</span>"
    ]
  },
  {
    "objectID": "third_sdm.html#개념적-모델",
    "href": "third_sdm.html#개념적-모델",
    "title": "\n5  공간데이터모델\n",
    "section": "\n5.2 개념적 모델",
    "text": "5.2 개념적 모델\n\n5.2.1 객체-기반 모델\n\n5.2.2 필드-기반 모델",
    "crumbs": [
      "공간데이터모델과 GIS 데이터베이스",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>공간데이터모델</span>"
    ]
  },
  {
    "objectID": "third_sdm.html#논리적-모델",
    "href": "third_sdm.html#논리적-모델",
    "title": "\n5  공간데이터모델\n",
    "section": "\n5.3 논리적 모델",
    "text": "5.3 논리적 모델\n\n5.3.1 벡터 모델\n\n5.3.1.1 개요\n피처 클래스(feature class)에 대한 개념적 설명\n필수 패키지를 설치한다.\n\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(tmap)\nlibrary(readxl)\n\n포인트 레이어로서 서울시 역 위치에 대한 셰이프 파일을 생성한다.\n\nseoul &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\")\nseoul_subst_coords &lt;- read_excel(\"D:/My R/GIS/서울시 역사마스터 정보.xlsx\") \n\nseoul_subst_coords |&gt; \n  st_as_sf(coords = c(\"위도\", \"경도\"), crs = 4326) |&gt; \n  st_transform(crs = 5179) |&gt; \n  st_intersection(seoul) -&gt; seoul_subst\n\n라인 레이어로서 서울시 도로망에 대한 셰이프 파일을 불러온다.\n\nseoul_sn &lt;- st_read(\"D:/My R/Vector Data Manipulation Korea/Korea_Transport_Database/seoul_link.shp\", options = \"ENCODING=CP949\")\n\n폴리곤 레이어로서 서울시 구 경계 셰이프 파일을 불러온다.\n\nseoul_gu &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\")\n\n세 개의 레이어를 합쳐 지도를 생성한다.\n\ntm_shape(seoul) + tm_polygons(col = \"gray98\") +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray70\") +\n  tm_shape(seoul_gu, is.master = TRUE) + tm_borders(lwd = 1.5) +\n  tm_shape(seoul_subst) + tm_symbols(col = \"black\", size = 0.15) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Feature Classes\", title.size = 1,\n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\n\n\n\n\n\n\nFigure 5.1: 피처 클래스\n\n\n\n\n\n5.3.1.2 구현\n\n5.3.1.3 물리적 모델\n\n5.3.2 래스터 모델\n\n5.3.2.1 개요\n\n5.3.2.2 구현\n\n5.3.2.3 물리적 모델\n\n\n\nFigure 5.1: 피처 클래스",
    "crumbs": [
      "공간데이터모델과 GIS 데이터베이스",
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>공간데이터모델</span>"
    ]
  },
  {
    "objectID": "part_4.html",
    "href": "part_4.html",
    "title": "벡터-기반 GIS 오퍼레이션",
    "section": "",
    "text": "이 파트에서는 다음의 내용을 다룬다.\n\n일반화(generalization)\n측정(measurement)\n벡터 레이어 생성\n근접성 분석(proximity analysis)\n공간적 선택(spatial selection)\n재분류(reclassification)\n중첩 분석(overlay analysis)",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션"
    ]
  },
  {
    "objectID": "vector_generalization.html",
    "href": "vector_generalization.html",
    "title": "\n7  일반화\n",
    "section": "",
    "text": "7.1 더글라스-포이커(Douglas-Peucker algorithm)\n여기서는 거제시를 사례로 더글라스-포이커 알고리즘을 적용하고자 한다. 기본 패키지를 설치한다.\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(tmap)\nlibrary(rmapshaper)\n기본 데이터를 불러온다.\nsigungu1 &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SIGUNGU1_2023_2Q.shp\", options = \"ENCODING=CP949\")\n거제시에 대한 데이터를 생성한다.\ngeojae &lt;- sigungu1 |&gt; \n  filter(\n    SGG1_NM == \"거제시\"\n  )\nqtm(geojae)\n거제시의 버텍스 객수를 센다.\ngeojae |&gt; st_geometry() |&gt; st_cast(\"POINT\") |&gt; length()\n\n[1] 182734\n서로 다른 허용오차(tolerance)를 적용하여 폴리곤을 생성한다. 0을 적용한다. 위와 동일한 결과가 나옴을 확인한다.\ngeojae.0 &lt;- geojae |&gt; \n  st_simplify(dTolerance = 0)\ngeojae.0 |&gt; st_geometry() |&gt; st_cast(\"POINT\") |&gt; length()\n\n[1] 182734\n50미터를 적용한다.\ngeojae.50 &lt;- geojae |&gt; \n  st_simplify(dTolerance = 50)\ngeojae.50 |&gt; st_geometry() |&gt; st_cast(\"POINT\") |&gt; length()\n\n[1] 1906\n100미터를 적용한다.\ngeojae.100 &lt;- geojae |&gt; \n  st_simplify(dTolerance = 100)\ngeojae.100 |&gt; st_geometry() |&gt; st_cast(\"POINT\") |&gt; length()\n\n[1] 918\n500미터를 적용한다.\ngeojae.500 &lt;- geojae |&gt; \n  st_simplify(dTolerance = 500)\ngeojae.500 |&gt; st_geometry() |&gt; st_cast(\"POINT\") |&gt; length()\n\n[1] 183\n1,000미터를 적용한다.\ngeojae.1000 &lt;- geojae |&gt; \n  st_simplify(dTolerance = 1000)\ngeojae.1000 |&gt; st_geometry() |&gt; st_cast(\"POINT\") |&gt; length()\n\n[1] 79\n서로 다른 허용오차를 적용한 지도를 제작한다. 우선 원 데이터(즉, 0미터)를 제작한다.\ntm_shape(geojae.0) + tm_polygons()\n허용오차 100미터 지도를 제작한다.\ntm_shape(geojae.100) + tm_polygons()\n허용오차 500미터 지도를 제작한다.\ntm_shape(geojae.500) + tm_polygons()\n허용오차 1,000미터 지도를 제작한다.\ntm_shape(geojae.500) + tm_polygons()",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>일반화</span>"
    ]
  },
  {
    "objectID": "vector_generalization.html#비스발리엄-화이엇visvalingam-whyatt-알고리즘",
    "href": "vector_generalization.html#비스발리엄-화이엇visvalingam-whyatt-알고리즘",
    "title": "\n7  일반화\n",
    "section": "\n7.2 비스발리엄-화이엇(Visvalingam-Whyatt) 알고리즘",
    "text": "7.2 비스발리엄-화이엇(Visvalingam-Whyatt) 알고리즘\n우리나라 시군구 단위의 데이터에 대한 서로 다른 단순화의 정도를 가진 지도를 제작한다.\n우선 0.1%의 버텍스를 남기는 단순화가 적용된 지도이다.\n\nsigungu1.0010 &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/3 Generalization/2023_2Q/SIGUNGU1_2023_2Q_GEN_0010.shp\", options = \"ENCODING=CP949\")\nqtm(sigungu1.0010)\n\n\n\n\n\n\n\n\nsigungu1.0010 |&gt; st_geometry() |&gt; st_cast(\"POINT\") |&gt; length()\n\n[1] 11707\n\n\n0.2%의 버텍스를 남기는 단순화가 적용된 지도이다.\n\nsigungu1.0020 &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/3 Generalization/2023_2Q/SIGUNGU1_2023_2Q_GEN_0020.shp\", options = \"ENCODING=CP949\")\nqtm(sigungu1.0020)\n\n\n\n\n\n\n\n\nsigungu1.0020 |&gt; st_geometry() |&gt; st_cast(\"POINT\") |&gt; length()\n\n[1] 16450\n\n\n0.3%의 버텍스를 남기는 단순화가 적용된 지도이다.\n\nsigungu1.0030 &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/3 Generalization/2023_2Q/SIGUNGU1_2023_2Q_GEN_0030.shp\", options = \"ENCODING=CP949\")\nqtm(sigungu1.0030)\n\n\n\n\n\n\n\n\nsigungu1.0030 |&gt; st_geometry() |&gt; st_cast(\"POINT\") |&gt; length()\n\n[1] 21193\n\n\n0.4%의 버텍스를 남기는 단순화가 적용된 지도이다.\n\nsigungu1.0040 &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/3 Generalization/2023_2Q/SIGUNGU1_2023_2Q_GEN_0040.shp\", options = \"ENCODING=CP949\")\nqtm(sigungu1.0040)\n\n\n\n\n\n\n\n\nsigungu1.0040 |&gt; st_geometry() |&gt; st_cast(\"POINT\") |&gt; length()\n\n[1] 25901\n\n\n0.5%의 버텍스를 남기는 단순화가 적용된 지도이다.\n\nsigungu1.0050 &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/3 Generalization/2023_2Q/SIGUNGU1_2023_2Q_GEN_0050.shp\", options = \"ENCODING=CP949\")\nqtm(sigungu1.0050)\n\n\n\n\n\n\n\n\nsigungu1.0050 |&gt; st_geometry() |&gt; st_cast(\"POINT\") |&gt; length()\n\n[1] 30803\n\n\n1%의 버텍스를 남기는 단순화가 적용된 지도이다.\n\nsigungu1.0100 &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/3 Generalization/2023_2Q/SIGUNGU1_2023_2Q_GEN_0100.shp\", options = \"ENCODING=CP949\")\nqtm(sigungu1.0100)\n\n\n\n\n\n\n\n\nsigungu1.0100 |&gt; st_geometry() |&gt; st_cast(\"POINT\") |&gt; length()\n\n[1] 54619\n\n\n5%의 버텍스를 남기는 단순화가 적용된 지도이다.\n\nsigungu1.0500 &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/3 Generalization/2023_2Q/SIGUNGU1_2023_2Q_GEN_0500.shp\", options = \"ENCODING=CP949\")\nqtm(sigungu1.0500)\n\n\n\n\n\n\n\n\nsigungu1.0500 |&gt; st_geometry() |&gt; st_cast(\"POINT\") |&gt; length()\n\n[1] 248845\n\n\n우선 10%의 버텍스를 남기는 단순화가 적용된 지도이다.\n\nsigungu1.1000 &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/3 Generalization/2023_2Q/SIGUNGU1_2023_2Q_GEN_1000.shp\", options = \"ENCODING=CP949\")\nqtm(sigungu1.1000)\n\n\n\n\n\n\n\n\nsigungu1.1000 |&gt; st_geometry() |&gt; st_cast(\"POINT\") |&gt; length()\n\n[1] 502582\n\n\n대표적인 두 개에 대해 완전한 지도를 완성한다.\n우선, 0.1%를 남기는 지도이다. 여타의 데이터를 불러온다.\n\nsido_poly.0100 &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/3 Generalization/2023_2Q/SIDO_Polyline_2023_2Q_GEN_0010.shp\", options = \"ENCODING=CP949\")\nbbox_seahae.0100 &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/3 Generalization/2023_2Q/BBOX_Seohae3_2023_2Q_GEN_0010.shp\", options = \"ENCODING=CP949\")\nbbox_ulleung.0100 &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/3 Generalization/2023_2Q/BBOX_Ulleung_2023_2Q_GEN_0010.shp\", options = \"ENCODING=CP949\")\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(sigungu1.0010) + tm_polygons() +\n  tm_shape(sido_poly.0100) + tm_lines(col = \"black\", lwd = 2) +\n  tm_shape(bbox_seahae.0100) + tm_lines() +\n  tm_shape(bbox_ulleung.0100) + tm_lines() +\n  tm_layout(inner.margins = c(0.02, 0.03, 0.02, 0.04)) +\n  tm_scale_bar(breaks = seq(0, 200, 50), color.dark = \"gray60\", position = c(0.48, 0.01))\nmy_map\n\n\n\n\n\n\n\n다음으로, 10%를 남기는 지도이다. 여타의 데이터를 불러온다.\n\nsido_poly.1000 &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/3 Generalization/2023_2Q/SIDO_Polyline_2023_2Q_GEN_0020.shp\", options = \"ENCODING=CP949\")\nbbox_seahae.1000 &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/3 Generalization/2023_2Q/BBOX_Seohae3_2023_2Q_GEN_0020.shp\", options = \"ENCODING=CP949\")\nbbox_ulleung.1000 &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/3 Generalization/2023_2Q/BBOX_Ulleung_2023_2Q_GEN_0020.shp\", options = \"ENCODING=CP949\")\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(sigungu1.1000) + tm_polygons() +\n  tm_shape(sido_poly.1000) + tm_lines(col = \"black\", lwd = 2) +\n  tm_shape(bbox_seahae.1000) + tm_lines() +\n  tm_shape(bbox_ulleung.1000) + tm_lines() +\n  tm_layout(inner.margins = c(0.02, 0.03, 0.02, 0.04)) +\n  tm_scale_bar(breaks = seq(0, 200, 50), color.dark = \"gray60\", position = c(0.48, 0.01))\nmy_map",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>일반화</span>"
    ]
  },
  {
    "objectID": "vector_measurement.html",
    "href": "vector_measurement.html",
    "title": "\n8  측정\n",
    "section": "",
    "text": "8.1 폴리곤의 면적과 주변길이\n필수적인 패키지를 불러온다.\nlibrary(sf)\nlibrary(tmap)\nlibrary(tidyverse)\n서울시의 구와 동 단위 데이터를 예제로 사용한다.\nseoul_gu &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\")\nseoul_dong &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\")\n면적을 계산한다.\nst_area(seoul_gu)\nst_area(seoul_dong)\n주변길이(perimeter)를 계산한다.\nseoul_gu |&gt; \n  st_cast(\"MULTILINESTRING\") |&gt; \n  st_length()\nseoul_dong |&gt; \n  st_cast(\"MULTILINESTRING\") |&gt; \n  st_length()",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>측정</span>"
    ]
  },
  {
    "objectID": "vector_measurement.html#폴리곤의-형태",
    "href": "vector_measurement.html#폴리곤의-형태",
    "title": "\n8  측정\n",
    "section": "\n8.2 폴리곤의 형태",
    "text": "8.2 폴리곤의 형태\n콤펙트비(compactness ratio)를 다음의 수식에 의거해 계산한다.\n\\[\nS_1=A/(P^2/4\\pi)=4\\pi A/P^2\n\\]\n\\[\nS_2=(2\\pi \\sqrt{A/\\pi})/P=2\\sqrt{\\pi A}/P=3.545\\sqrt{A}/P\n\\]\n함수를 작성한다.\n\nsnu_poly_shape_index &lt;- function(poly.shp){\n  A &lt;- st_area(poly.shp)\n  P &lt;- st_length(st_cast(poly.shp, \"MULTILINESTRING\"))\n  S.1 &lt;- 4*pi*A/P^2\n  S.2 &lt;- sqrt(S.1)\n  poly.shp$S1 &lt;- as.numeric(S.1)\n  poly.shp$S2 &lt;- as.numeric(S.2)\n  poly.shp\n}\n\n서울시 구의 콤펙트비를 계산한다.\n\nseoul_gu &lt;- snu_poly_shape_index(seoul_gu)\nseoul_gu |&gt; slice_max(S1) \n\nSimple feature collection with 1 feature and 11 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 961989.7 ymin: 1952338 xmax: 966325.5 ymax: 1958028\nProjected CRS: KGD2002 / Unified CS\n  SGG1_CD SD_CD      SD_NM SG1_CD     SG1_NM SGG1_NM          SGG1_FNM\n1   11070    11 서울특별시     11 서울특별시  중랑구 서울특별시 중랑구\n       Eng_NM Chn_NM        S1        S2                       geometry\n1 Jungnang-gu 中浪區 0.6725585 0.8200967 POLYGON ((964125.5 1952433,...\n\nseoul_gu |&gt; slice_min(S1)\n\nSimple feature collection with 1 feature and 11 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 939273.8 ymin: 1941770 xmax: 947237.7 ymax: 1946700\nProjected CRS: KGD2002 / Unified CS\n  SGG1_CD SD_CD      SD_NM SG1_CD     SG1_NM SGG1_NM          SGG1_FNM  Eng_NM\n1   11170    11 서울특별시     11 서울특별시  구로구 서울특별시 구로구 Guro-gu\n  Chn_NM        S1        S2                       geometry\n1 九老區 0.2072557 0.4552534 POLYGON ((940771.4 1942203,...\n\n\n서울시 동의 콤펙트비를 계산한다.\n\nseoul_dong &lt;- snu_poly_shape_index(seoul_dong)\nseoul_dong |&gt; slice_max(S1) \n\nSimple feature collection with 1 feature and 17 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 964999.1 ymin: 1944822 xmax: 966120.8 ymax: 1945928\nProjected CRS: KGD2002 / Unified CS\n    EMD_ID SD_CD      SD_NM SG1_CD     SG1_NM SG2_CD     SG2_NM SGG1_CD SGG1_NM\n1 11240610    11 서울특별시     11 서울특별시     11 서울특별시   11240  송파구\n  SGG2_CD SGG2_NM EMD_NM_y                   EMD_FNM            Eng_NM  Chn_NM\n1   11240  송파구  송파1동 서울특별시 송파구 송파1동 Songpa 1(il)-dong 松坡1洞\n         S1        S2                       geometry\n1 0.8282855 0.9101019 POLYGON ((965536.1 1944822,...\n\nseoul_dong |&gt; slice_min(S1)\n\nSimple feature collection with 1 feature and 17 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 959962.2 ymin: 1949952 xmax: 962352.3 ymax: 1951280\nProjected CRS: KGD2002 / Unified CS\n    EMD_ID SD_CD      SD_NM SG1_CD     SG1_NM SG2_CD     SG2_NM SGG1_CD SGG1_NM\n1 11040690    11 서울특별시     11 서울특별시     11 서울특별시   11040  성동구\n  SGG2_CD SGG2_NM EMD_NM_y                  EMD_FNM         Eng_NM Chn_NM\n1   11040  성동구   송정동 서울특별시 성동구 송정동 Songjeong-dong 松亭洞\n         S1        S2                       geometry\n1 0.2043469 0.4520475 POLYGON ((961792.8 1949976,...\n\n\n서울시 구의 콤펙트비 지도를 제작한다.\n\nmin.val &lt;- seoul_gu |&gt; pull(S1) |&gt; min() |&gt; format(digits = 3)\nmax.val &lt;- seoul_gu |&gt; pull(S1) |&gt; max() |&gt; format(digits = 3)\nmy_map &lt;- tm_shape(seoul_gu) + \n  tm_polygons(\n    col = \"S1\", palette = \"BuPu\", style = \"fixed\", breaks = c(0, 0.3, 0.4, 0.5, 0.6, 1),\n    labels = c(paste0(\"&lt; 0.3\", \" (Min. \", min.val, \")\"), \"0.3 ~ 0.4\", \"0.4 ~ 0.5\", \"0.5 ~ 0.6\", paste0(\"&gt;= 0.6\", \" (Max. \", max.val, \")\")),     title = \"Compactness\", legend.show = TRUE) +\n  tm_legend(legend.position = c(0.81, 0.03)) + \n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.13), \n            title = \"Compactness Ratio\", title.size = 1,\n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map \n\n\n\n\n\n\n\n서울시 동의 콤펙트비 지도를 제작한다.\n\nmin.val &lt;- seoul_dong |&gt; pull(S1) |&gt; min() |&gt; format(digits = 3)\nmax.val &lt;- seoul_dong |&gt; pull(S1) |&gt; max() |&gt; format(digits = 3)\nmy_map &lt;- tm_shape(seoul_dong) + \n  tm_polygons(\n    col = \"S1\", \n    palette = \"BuPu\", \n    style = \"fixed\", \n    breaks = c(0, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 1),\n    labels = c(paste0(\"&lt; 0.3\", \" (Min. \", min.val, \")\"), \"0.3 ~ 0.4\", \"0.4 ~ 0.5\", \"0.5 ~ 0.6\", \"0.6 ~ 0.7\", \"0.7 ~ 0.8\", paste0(\"&gt;= 0.8\", \" (Max. \", max.val, \")\")),     title = \"Compactness\", legend.show = TRUE) +\n  tm_shape(seoul_gu) + tm_borders(col = \"gray20\", lwd = 2) +\n  tm_legend(legend.position = c(0.81, 0.03)) + \n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.13), \n            title = \"Compactness Ratio\", title.size = 1,\n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>8</span>  <span class='chapter-title'>측정</span>"
    ]
  },
  {
    "objectID": "vector_layer_creation.html",
    "href": "vector_layer_creation.html",
    "title": "\n9  벡터 레이어 생성\n",
    "section": "",
    "text": "9.1 경위도 좌표값을 이용한 지오코딩(Geocoding)\n서울 열린데이터 광장에서 구한 지하철역의 경위도 좌표값을 바탕으로 포인트 레이터를 생성한다.\n필수 패키지를 불러온다.\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(tmap)\nlibrary(readxl)\n서울시의 관련 데이터를 불러온다.\nseoul &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\", options = \"ENCODING=CP949\")\nseoul_gu &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\", options = \"ENCODING=CP949\")\nseoul_dong &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\", options = \"ENCODING=CP949\")\n서울 지하철역 위치 관련 데이터를 불러와 sf 객체를 생성한다. 그것을 디스크에 저장한다.\nseoul_subst_coords &lt;- read_excel(\"D:/My R/GIS/서울시 역사마스터 정보.xlsx\") \n\nseoul_subst_coords |&gt; \n  st_as_sf(coords = c(\"위도\", \"경도\"), crs = 4326) |&gt; \n  st_transform(crs = st_crs(seoul)) |&gt; \n  st_intersection(seoul) -&gt; seoul_subst\n\nst_write(seoul_subst, dsn = \"D:/My R/Vector Data Manipulation Korea/seoul_subst.shp\", driver = \"ESRI Shapefile\", append = FALSE, layer_options = \"ENCODING=CP949\")\n\nDeleting layer `seoul_subst' using driver `ESRI Shapefile'\nWriting layer `seoul_subst' to data source \n  `D:/My R/Vector Data Manipulation Korea/seoul_subst.shp' using driver `ESRI Shapefile'\noptions:        ENCODING=CP949 \nWriting 401 features with 7 fields and geometry type Point.\n지도를 제작한다.\ntm_shape(seoul_gu) + tm_polygons(col = \"gray95\") +\n  tm_shape(seoul_subst) + tm_symbols(col = \"black\", size = 0.15) +\n  tm_legend(legend.position = c(0.75, 0.03)) +\n  tm_add_legend(type = \"symbol\", size = 0.80, col = \"black\", shape = 16, labels = \"Subway Stations\", title = \"\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Geocoding: Coordinates\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>벡터 레이어 생성</span>"
    ]
  },
  {
    "objectID": "vector_layer_creation.html#주소를-이용한-지오코딩",
    "href": "vector_layer_creation.html#주소를-이용한-지오코딩",
    "title": "\n9  벡터 레이어 생성\n",
    "section": "\n9.2 주소를 이용한 지오코딩",
    "text": "9.2 주소를 이용한 지오코딩\n스타벅스 데이터 속에는 주소 컬럼도 있지만 경위도 좌표값도 포함되어 있다. 우선 위의 지하철역과 동일한 방식으로 지오코딩을 실행하고 sf 객체를 생성한 후 디스크에 저장한다.\n\nstarbucks &lt;- read_excel(\"D:/My R/GIS/스타벅스.xlsx\") # 주소 파일 불러오기\nstarbucks |&gt; \n  distinct(\n    Sotre_nm, .keep_all = TRUE\n  ) -&gt; starbucks\n\nstarbucks |&gt; \n  st_as_sf(coords = c(\"Xcoordinate\", \"Ycoordinate\"), crs = 4326) |&gt; \n  st_transform(crs = st_crs(seoul)) |&gt; \n  st_intersection(seoul) -&gt; starbucks_seoul_real\n  \nst_write(starbucks_seoul_real, dsn = \"D:/My R/Vector Data Manipulation Korea/starbucks_seoul.shp\", driver = \"ESRI Shapefile\", append = FALSE, layer_options = \"ENCODING=CP949\")\n\n위의 방식으로 만들어진 스타벅스의 실제 위치에 대한 파일을 불러들인다.\n\nstarbucks_seoul_real &lt;- st_read(\"D:/My R/Vector Data Manipulation Korea/starbucks_seoul.shp\")\n\n다음은 스타벅스의 주소를 기반으로 ggmap 패키지의 오픈 API를 이용하여 지오코딩하는 과정을 보여준다. 생성된 sf 객체를 디스크에 저장하는 과정까지 포함되어 있다.\n\nlibrary(ggmap)\n\nmy_google_key = \"\"\nregister_google(key = my_google_key) # 구글 키 등록\n\nstarbucks |&gt; pull(Address) |&gt; \n  as.character() |&gt; \n  enc2utf8() |&gt; \n  geocode(\n    key = key, \n    simplify = TRUE\n  ) |&gt; \n  filter(\n    !is.na(lon)\n  ) -&gt; starbucks_geocode\n\nstarbucks_geocode |&gt; \n  bind_cols(starbucks) |&gt; \n  filter(\n    !is.na(lon)\n  ) -&gt; starbucks_geocode_final\n\nstarbucks_geocode_final |&gt; \n  st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326) |&gt; \n  st_transform(crs = st_crs(seoul)) |&gt; \n  st_intersection(seoul) -&gt; starbucks_seoul\n\nst_write(starbucks_seoul, dsn = \"D:/My R/Vector Data Manipulation Korea/starbucks_seoul_geocode.shp\", driver = \"ESRI Shapefile\", append = FALSE, layer_options = \"ENCODING=CP949\")\n\n위에서 생성된 스타벅스의 주소 지오코딩 파일을 불러들인다.\n\nstarbucks_seoul_geocoding &lt;- st_read(\"D:/My R/Vector Data Manipulation Korea/starbucks_seoul.shp\", options = \"ENCODING=CP949\")\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_gu) + tm_polygons(col = \"gray95\") +\n  tm_shape(starbucks_seoul_real) + tm_dots(col = \"red\", size = 0.15, alpha = 1) +\n  tm_shape(starbucks_seoul_geocoding) + tm_dots(col = \"black\", size = 0.2, alpha = 0.3) +\n  tm_legend(legend.position = c(0.75, 0.03)) +\n  tm_add_legend(type = \"symbol\", size = 0.80, col = \"black\", shape = 16, labels = \"Starbucks\", title = \"\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Geocoding: Addresses\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>벡터 레이어 생성</span>"
    ]
  },
  {
    "objectID": "vector_layer_creation.html#센트로이드",
    "href": "vector_layer_creation.html#센트로이드",
    "title": "\n9  벡터 레이어 생성\n",
    "section": "\n9.3 센트로이드",
    "text": "9.3 센트로이드\n\n9.3.1 컨벡스헐(convex hull)\nst_convex_hull() 함수를 이용하여 서울시 구에 대한 컨벡스헐을 생성한다.\n\nseoul_gu |&gt; \n  st_convex_hull() -&gt; seoul_gu_ch\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_gu) + tm_polygons() +\n  tm_shape(seoul_gu_ch) + tm_borders(col = \"red\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n9.3.2 최소포괄직사각형(minimum bounding rectangle)\nst_bbox() 함수를 활용하면 MBR을 생성할 수 있다. 우선 서울시 전체의 MBR을 생성한다.\n\nseoul_gu |&gt; \n  st_bbox() |&gt; \n  st_as_sfc() -&gt; seoul_mbr\n\n그런데 서울시 구 각각에 대해 MBR을 만드는 것은 쉽지 않다. map() 함수를 활용하여 구 각각에 대한 MBR을 생성하고 그것을 모두 합쳐 하나의 sf 객체를 생성한다.\n\nbbox_wrap &lt;- function(x) st_as_sfc(st_bbox(x))\nseoul_gu_mbr &lt;- seoul_gu |&gt; \n  group_by(SGG1_CD) |&gt; \n  nest() |&gt; \n  ungroup() |&gt; \n  mutate(\n    bbox = map(data, bbox_wrap)\n  ) |&gt; \n  mutate(\n    geometry = st_sfc(unlist(bbox, recursive = FALSE), crs = st_crs(seoul))\n  ) |&gt; \n  select(-data, -bbox) |&gt; \n  st_as_sf()\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_gu) + tm_polygons() +\n  tm_shape(seoul_gu_mbr) + tm_borders(col = \"red\", lty = 2, lwd = 1) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Minimum Bounding Rectangle\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>벡터 레이어 생성</span>"
    ]
  },
  {
    "objectID": "vector_layer_creation.html#평균중심점mc",
    "href": "vector_layer_creation.html#평균중심점mc",
    "title": "\n9  벡터 레이어 생성\n",
    "section": "\n9.4 평균중심점(MC)",
    "text": "9.4 평균중심점(MC)",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>벡터 레이어 생성</span>"
    ]
  },
  {
    "objectID": "vector_layer_creation.html#최소포괄직사각형중심점cmbr",
    "href": "vector_layer_creation.html#최소포괄직사각형중심점cmbr",
    "title": "\n9  벡터 레이어 생성\n",
    "section": "\n9.5 최소포괄직사각형중심점(CMBR)",
    "text": "9.5 최소포괄직사각형중심점(CMBR)\nst_centroid() 함수를 이용하여 앞에서 생성한 CMB의 센트로이드를 생성한다.\n\nseoul_gu_mbr |&gt; \n  st_centroid() -&gt; seoul_gu_mbr_center\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_gu) + tm_polygons() +\n  tm_shape(seoul_gu_mbr) + tm_borders(col = \"red\", lty = 2, lwd = 1) +\n  tm_shape(seoul_gu_mbr_center) + tm_dots(col = \"black\", size = 0.15) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"CMBR\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>벡터 레이어 생성</span>"
    ]
  },
  {
    "objectID": "vector_layer_creation.html#질량중심점cm",
    "href": "vector_layer_creation.html#질량중심점cm",
    "title": "\n9  벡터 레이어 생성\n",
    "section": "\n9.6 질량중심점(CM)",
    "text": "9.6 질량중심점(CM)\nst_centroid() 함수를 이용하여 서울시 구의 질량중심점을 생성한다.\n\nseoul_gu |&gt; \n  st_centroid() -&gt; seoul_gu_cm\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_gu) + tm_polygons() +\n  tm_shape(seoul_gu_cm) + tm_dots(col = \"black\", size = 0.15) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Center of Mass\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\nst_centroid() 함수를 이용하여 서울시 동의 질량중심점을 생성한다.\n\nseoul_dong |&gt; \n  st_centroid() -&gt; seoul_dong_cm\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_dong) + tm_polygons() +\n  tm_shape(seoul_dong_cm) + tm_dots(col = \"black\", size = 0.15) +\n  tm_shape(seoul_gu) + tm_borders(col = \"black\", lwd = 1) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Center of Mass\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n그런데 일부 질량중심점이 폴리곤의 외부에 위치할 수 있다. 이 문제는 st_point_on_surface() 함수를 사용하여 교정할 수 있다.\n\nseoul_dong |&gt; \n  st_point_on_surface() -&gt; seoul_dong_cm_on\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_dong) + tm_polygons() +\n  tm_shape(seoul_dong_cm_on) + tm_dots(col = \"black\", size = 0.15) +\n  tm_shape(seoul_gu) + tm_borders(col = \"black\", lwd = 1) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Center of Mass 2\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>9</span>  <span class='chapter-title'>벡터 레이어 생성</span>"
    ]
  },
  {
    "objectID": "vector_selection.html",
    "href": "vector_selection.html",
    "title": "\n11  공간적 선택\n",
    "section": "",
    "text": "11.1 공간적 관계에 기반한 공간적 선택",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>공간적 선택</span>"
    ]
  },
  {
    "objectID": "vector_selection.html#공간적-관계에-기반한-공간적-선택",
    "href": "vector_selection.html#공간적-관계에-기반한-공간적-선택",
    "title": "\n11  공간적 선택\n",
    "section": "",
    "text": "11.1.1 준비\n필수적인 패키지를 불러온다.\n\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(tmap)\nlibrary(readxl)\n\n서울의 관련 데이터를 불러온다.\n\nseoul &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\", options = \"ENCODING=CP949\")\nseoul_gu &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\", options = \"ENCODING=CP949\")\nseoul_dong &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\", options = \"ENCODING=CP949\")\n\n\n11.1.2 포인트-투-포인트\n지하철역에 가장 가까이에 위치한 스타벅스를 선택한다. 우선 9장에서 생성한 지하철역 데이터를 불러온다.\n\nseoul_subst &lt;- st_read(\"D:/My R/Vector Data Manipulation Korea/seoul_subst.shp\", options = \"ENCODING=CP949\")\n\noptions:        ENCODING=CP949 \nReading layer `seoul_subst' from data source \n  `D:\\My R\\Vector Data Manipulation Korea\\seoul_subst.shp' using driver `ESRI Shapefile'\nSimple feature collection with 401 features and 7 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 938028.4 ymin: 1938762 xmax: 971377.4 ymax: 1965651\nProjected CRS: KGD2002 / Unified CS\n\n\n마찬가지로 9장에서 생성한 스타벅스 데이터를 불러온다.\n\nstarbucks_seoul_real &lt;- st_read(\"D:/My R/Vector Data Manipulation Korea/starbucks_seoul.shp\", options = \"ENCODING=CP949\")\n\noptions:        ENCODING=CP949 \nReading layer `starbucks_seoul' from data source \n  `D:\\My R\\Vector Data Manipulation Korea\\starbucks_seoul.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 520 features and 9 fields\nGeometry type: POINT\nDimension:     XY\nBounding box:  xmin: 939637.5 ymin: 1938775 xmax: 971226.8 ymax: 1962474\nProjected CRS: KGD2002 / Unified CS\n\n\n공간적 관계에 기반한 공간적 선택을 실행한다.\n\nseoul_subst |&gt; \n  st_nearest_feature(starbucks_seoul_real) -&gt; starbucks_index\nstarbucks_seoul_real |&gt; \n  slice(starbucks_index) |&gt; \n  distinct(\n    Sotre_nm, .keep_all = TRUE\n  ) -&gt; starbucks_closest_station_unique\n\n지도를 생성한다.\n\nmy.map &lt;- tm_shape(seoul_gu) + tm_polygons(lwd = 2, col = \"gray95\") +\n  tm_shape(starbucks_seoul_real) + tm_dots(size = 0.15, col = \"gray50\") +\n  tm_shape(seoul_subst) + tm_dots(size = 0.15, col = \"#377eb8\") +\n  tm_shape(starbucks_closest_station_unique) + tm_dots(size = 0.15, col = \"#e41a1c\") +\n  tm_legend(legend.position = c(0.75, 0.03)) +\n  tm_add_legend(type = \"symbol\", size = 0.50, col = c(\"#377eb8\", \"#e41a1c\", \"gray50\"), shape = 16, labels = c(\"Subway Stations (401)\", \"Nearest Starbucks (254)\", \"Not Selected Starbucks (266)\"), title = \"\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Spatial Selection: Point-to-Point\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy.map\n\n\n\n\n\n\n\n\n11.1.3 포인트-인-폴리곤\n관악구 내의 스타벅스만 선택한다. 우선 관악구만 선택한다.\n\ngwanak_gu &lt;- seoul_gu |&gt; \n  filter(\n    SGG1_NM == \"관악구\"\n  )\n\n관악구 내에 포함되는 스타벅스를 선택한다.\n\n# starbucks_gwanak &lt;- starbucks_seoul_real[which(lengths(st_intersects(starbucks_seoul_real, gwanak_gu)) &gt; 0), ]\n\nstarbucks_seoul_real |&gt; \n  st_intersects(gwanak_gu) |&gt; \n  lengths() &gt; 0 -&gt; sel_vec\nstarbucks_seoul_real |&gt; \n  filter(sel_vec) -&gt; starbucks_gwanak\n\n지도로 나타낸다.\n\nmy_map &lt;- tm_shape(seoul_gu) + tm_polygons(col = \"gray98\", lwd = 1) +\n  tm_shape(gwanak_gu) + tm_polygons(col = \"gray70\") +\n  tm_shape(starbucks_seoul_real) + tm_dots(col = \"black\", size = 0.15) +\n  tm_shape(starbucks_gwanak) + tm_dots(col = \"red\", size = 0.2) +\n  tm_legend(legend.position = c(0.80, 0.05)) +\n  tm_add_legend(type = \"symbol\", size = 0.50, col = \"black\", shape = 16, labels = \"Starbucks\", title = \"\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Spatial Selection: Point-in-Polygon\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n11.1.4 라인-온-폴리곤\n서울시 도로망 데이터를 불러온다.\n\nseoul_sn &lt;- st_read(\"D:/My R/Vector Data Manipulation Korea/Korea_Transport_Database/seoul_link.shp\", options = \"ENCODING=CP949\")\n\n중구만 선택한다.\n\njung_gu &lt;- seoul_gu |&gt; \n  filter(\n    SGG1_NM == \"중구\"\n  )\n\n중구와 인터섹터의 관계에 있는 도로만 선택한다.\n\nseoul_sn |&gt; \n  st_intersects(jung_gu) |&gt; \n  lengths() &gt; 0 -&gt; sel_index\nseoul_sn |&gt; \n  filter(sel_index) -&gt; jung_gu_sn\n\n지도를 생성한다.\n\nmy_map &lt;- tm_shape(seoul_gu, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 2) +\n  tm_shape(jung_gu) + tm_polygons(col = \"gray70\", border.col = \"gray10\", lwd = 2) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray70\") +\n  tm_shape(jung_gu_sn) + tm_lines(col = \"red\", lwd = 2) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Spatial Selection: Line-on-Polygon\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n중구만 확대한 지도를 제작한다.\n\nmy_map &lt;- tm_shape(jung_gu) + tm_polygons(col = \"gray70\", border.col = \"gray10\", lwd = 2) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray70\") +\n  tm_shape(jung_gu_sn) + tm_lines(col = \"red\", lwd = 2) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 2, 0.5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n11.1.5 폴리곤-온-폴리곤\n남부순환로로부터 1,000m 이내 지역에 대한 버퍼를 통해 동을 선택한다. 우선 버퍼를 생성한다.\n\nnambu_cir &lt;- seoul_sn |&gt; \n  filter(\n    ROAD_NAME %in% c(\"남부순환로\")\n  )\nnambu_cir |&gt; \n  st_buffer(dist = 1000) |&gt; \n  st_union() -&gt; nambu_cir_1000\n\n‘일부 교차’, ‘센트로이드 포함’, ’완전 포함’으로 분류하기 위한 작업을 한다. 우선 동의 센트로이드를 계산한다.\n\nseoul_dong |&gt; \n  st_centroid() -&gt; seoul_dong_centroid\n\n\n# 일부 교차\nseoul_dong |&gt; \n  st_intersects(nambu_cir_1000) |&gt; \n  lengths() &gt; 0 -&gt; sel_index_1\nseoul_dong |&gt; \n  filter(sel_index_1) -&gt; seoul_dong_1\n\n# 센트로이드 포함\nseoul_dong_centroid |&gt; \n  st_intersects(nambu_cir_1000) |&gt; \n  lengths() &gt; 0 -&gt; sel_index_2\nseoul_dong |&gt; \n  filter(sel_index_2) -&gt; seoul_dong_2\n\n# 완전 포함\nseoul_dong |&gt; \n  st_covered_by(nambu_cir_1000) |&gt; \n  lengths() &gt; 0 -&gt; sel_index_3\nseoul_dong |&gt; \n  filter(sel_index_3) -&gt; seoul_dong_3\n\n’일부 교차’에 대한 지도를 생성한다.\n\nmy_map &lt;- tm_shape(seoul_dong) + tm_polygons(col = \"gray98\", border.col = \"gray30\") +\n  tm_shape(seoul_dong_1) + tm_polygons(col = \"gray50\", border.col = \"gray30\") +\n  tm_shape(nambu_cir_1000) + tm_borders(col = \"black\", lwd = 3) +\n  tm_shape(seoul_gu) + tm_borders(lwd = 2, col = \"gray20\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Spatial Selection: Polygon-on-Polygon 1\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n’센트로이드 포함’에 대한 지도를 생성한다.\n\nmy_map &lt;- tm_shape(seoul_dong) + tm_polygons(col = \"gray98\", border.col = \"gray30\") +\n  tm_shape(seoul_dong_2) + tm_polygons(col = \"gray50\", border.col = \"gray30\") +\n  tm_shape(nambu_cir_1000) + tm_borders(col = \"black\", lwd = 3) +\n  tm_shape(seoul_gu) + tm_borders(lwd = 2, col = \"gray20\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Spatial Selection: Polygon-on-Polygon 2\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n’완전 포함’에 대한 지도를 생성한다.\n\nmy_map &lt;- tm_shape(seoul_dong) + tm_polygons(col = \"gray98\", border.col = \"gray30\") +\n  tm_shape(seoul_dong_3) + tm_polygons(col = \"gray50\", border.col = \"gray30\") +\n  tm_shape(nambu_cir_1000) + tm_borders(col = \"black\", lwd = 3) +\n  tm_shape(seoul_gu) + tm_borders(lwd = 2, col = \"gray20\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Spatial Selection: Polygon-on-Polygon 3\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>11</span>  <span class='chapter-title'>공간적 선택</span>"
    ]
  },
  {
    "objectID": "vector_reclassification.html",
    "href": "vector_reclassification.html",
    "title": "\n12  재분류\n",
    "section": "",
    "text": "12.1 준비\n필수적인 패키지를 불러온다.\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(tmap)\nlibrary(spdep)\n서울시 토지피복 데이터를 불러온다.\nseoul_landcover_M &lt;- st_read(\"D:/My R/Vector Data Manipulation Korea/Korea_Landcover/seoul_landcover_M_2023.shp\", options = \"ENCODING=CP949\")\nseoul_landcover_L &lt;- st_read(\"D:/My R/Vector Data Manipulation Korea/Korea_Landcover/seoul_landcover_L_2023.shp\", options = \"ENCODING=CP949\")\n서울시 행정구역 관련 데이터를 불러온다.\nseoul_gu &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\", options = \"ENCODING=CP949\")\nseoul_dong &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\", options = \"ENCODING=CP949\")\nseoul_sido &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\", options = \"ENCODING=CP949\")",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>재분류</span>"
    ]
  },
  {
    "objectID": "vector_reclassification.html#합역-spatial-aggregation",
    "href": "vector_reclassification.html#합역-spatial-aggregation",
    "title": "\n12  재분류\n",
    "section": "\n12.3 합역 Spatial Aggregation",
    "text": "12.3 합역 Spatial Aggregation\n\n12.3.1 무작위 합역 프로세스\n다음과 같은 함수를 사용한다.\n\nutd.spatial.random.aggregation &lt;- function (nhbr, m.region)\n{\n\n  # purpose: Generating a swm (gal format) of a spatial random aggregation from a binary swm of a polygon layer \n  # Arguments:\n  #   nhbr: a swm (gal formal) of an input polygon layer\n  #   m.region: the target number of polygons \n  # Fuction called:\n  #   utd.rank.out (from Monghyeon)\n\n##### First part: Extracting the an ggregation info (will be stored in sra.res) ragarding which areal units are aggregated to any seed areal unit\n\n# Randomly select a set of seed units (m.region)\n    n &lt;- max(nhbr[,1])\n    seed.num &lt;- sample(1:n, m.region)\n# Define two final data frames; the length of sra.res will increase, while the length of nhbr.res will decrease\n    sra.res &lt;- data.frame(seed.num, seed.num)\n    nhbr.res &lt;- nhbr\n# Delete entries in nhbr.res related to the seed units\n    for (i in 1:m.region)\n    {\n        a &lt;- seed.num[i]\n        nhbr.res &lt;- nhbr.res[!nhbr.res[,2]==a,]\n    }\n# Delete entries in sra.res and add entries in sra.res while looping\n    repeat\n    {\n        for (j in 1:m.region)\n        {\n            bb &lt;- seed.num[j]\n            col.set &lt;- vector()\n            nhbr.id &lt;- sra.res[,2][sra.res[,1]==bb]\n            for (dd in 1:length(nhbr.id))\n            {\n                nhbr.id.i &lt;- nhbr.res[,2][nhbr.res[,1]==nhbr.id[dd]]\n                col.set &lt;- c(col.set, nhbr.id.i)\n            }\n            if (length(col.set)!=0)\n            {\n                col.selected &lt;- sample(c(unique(col.set), bb), 1)\n                if (col.selected!=bb)\n                {\n                    sra.res &lt;- rbind(sra.res, c(bb, col.selected))\n                    nhbr.res &lt;- nhbr.res[!nhbr.res[,2]==col.selected,]\n                }\n            }\n        if (length(nhbr.res[,1])==0) break\n        }\n        if (length(nhbr.res[,1])==0) break\n    }   \n# Obtain the final sra.res\n    colnames(sra.res) &lt;- c(\"seed.id\", \"agg.id\")\n    sra.res &lt;- sra.res[order(sra.res$seed.id, sra.res$agg.id),]\n\n##### Second part: Constructing a swm on the basis of the aggregation info (will be stored in new.swm.1)\n    for (kk in 1:m.region)\n    {\n        nhbr.id.new &lt;- sra.res[,2][sra.res[,1]==seed.num[kk]]\n        nhbr.new.num &lt;- length(nhbr.id.new)\n        if (nhbr.new.num==0) {next}\n        new.nhbr.vec &lt;- vector()\n        for (mm in 1:nhbr.new.num)\n        {\n            nhbr.id.old &lt;- nhbr[,1][nhbr[,2]==nhbr.id.new[mm]]\n            nhbr.old.num &lt;- length(nhbr.id.old)\n            if (nhbr.old.num==0) {next}\n            for (nn in 1:nhbr.old.num)\n            {\n                new.nhbr.id &lt;- sra.res[,1][sra.res[,2]==nhbr.id.old[nn]]\n                new.nhbr.vec &lt;- c(new.nhbr.vec, new.nhbr.id)\n            }\n        }\n        new.nhbr.vec &lt;- unique(new.nhbr.vec)\n        length.vec &lt;- length(new.nhbr.vec)\n        if (kk==1)\n            {new.nhbr.res &lt;- data.frame(row.id=rep(seed.num[kk], length.vec), col.id=new.nhbr.vec)}\n        else \n            {new.nhbr.res &lt;- rbind(new.nhbr.res, cbind(row.id=rep(seed.num[kk], length.vec), col.id=new.nhbr.vec))}\n    }\n    new.nhbr.res &lt;- new.nhbr.res[!new.nhbr.res[,1]==new.nhbr.res[,2],]\n    new.nhbr.res &lt;- cbind(new.nhbr.res, weights=rep(1,length(new.nhbr.res[,1])))\n    new.nhbr.res &lt;- new.nhbr.res[order(new.nhbr.res$row.id, new.nhbr.res$col.id),]\n\n##### Third part: Updating the new swm with new IDs (will be stored in new.swm.2)\n    utd.rank.out &lt;- function(a.vec)\n    {\n        a.vec &lt;- as.vector(a.vec)\n        A &lt;- as.data.frame(cbind(1:length(a.vec),a.vec))\n        colnames(A) &lt;- c(\"id\", \"value\")\n        B &lt;- as.data.frame(cbind(unique(a.vec), rank(unique(a.vec))))\n        colnames(B) &lt;- c(\"value\", \"rank\")\n        res &lt;- merge(A, B, by=\"value\")\n        res[order(res$id),]$rank\n    }\n    \n    new.new.nhbr.res.1 &lt;- as.vector(utd.rank.out(new.nhbr.res[,1]))\n    new.new.nhbr.res.2 &lt;- as.vector(utd.rank.out(new.nhbr.res[,2]))\n    new.new.nhbr.res &lt;- data.frame(row.id=new.new.nhbr.res.1, col.id=new.new.nhbr.res.2, weights=rep(1,length(new.nhbr.res[,1])))\n    new.new.nhbr.res &lt;- new.new.nhbr.res[order(new.new.nhbr.res$row.id, new.new.nhbr.res$col.id),]\n\n    colnames(new.nhbr.res) &lt;- c(\"from\", \"to\", \"weights\")\n    colnames(new.new.nhbr.res) &lt;- c(\"from\", \"to\", \"weights\")\n    \n    all.res &lt;- list(sra=sra.res, new.swm.1=new.nhbr.res, new.swm.2=new.new.nhbr.res)\n}\n\n서울시의 426개 동을 25개로 RSA하는 한 가지 경우를 해 본다. 최종 결과로 합역의 인덱스 정보가 산출된다.\n\nseoul_dong_nb &lt;- poly2nb(seoul_dong, queen=FALSE)\nseoul_dong_sw &lt;- nb2listw(seoul_dong_nb, style=\"B\")\nseoul_dong_sn &lt;- listw2sn(seoul_dong_sw)\n\nseoul_sra_25_1 &lt;- utd.spatial.random.aggregation(seoul_dong_sn, 25)\nseoul_sra_25_1 &lt;- seoul_sra_25_1$sra\n\n위의 결과를 바탕으로 합역을 진행한다. 우선 seoul_dong에 일련번호를 생성한다. 이것을 공통키로 사용할 것이다.\n\nseoul_dong &lt;- seoul_dong |&gt; \n  mutate(\n    id = row_number()\n  )\n\n조인한다.\n\nseoul_dong_1 &lt;- seoul_dong |&gt; \n  left_join(seoul_sra_25_1, join_by(id == agg.id))\n\n합역한다.\n\nseoul_dong_sra_25_1 &lt;- seoul_dong_1 |&gt; \n  group_by(seed.id) |&gt; \n  summarize(\n    geometry = st_union(geometry),\n    .groups = \"drop\"\n  )\n\n지도를 작성한다.\n\nmy_map &lt;- tm_shape(seoul_gu) + tm_polygons(col = \"SGG1_NM\", border.col = NULL, legend.show = FALSE) +\n  tm_shape(seoul_dong_sra_25_1) + tm_borders(lwd = 1.5, col = \"gray20\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n두 번째 합역을 시행한다.\n\nseoul_sra_25_2 &lt;- utd.spatial.random.aggregation(seoul_dong_sn, 25)\nseoul_sra_25_2 &lt;- seoul_sra_25_2$sra\n\nseoul_dong_2 &lt;- seoul_dong |&gt; \n  left_join(seoul_sra_25_2, join_by(id == agg.id))\n\nseoul_dong_sra_25_2 &lt;- seoul_dong_2 |&gt; \n  group_by(seed.id) |&gt; \n  summarize(\n    geometry = st_union(geometry),\n    .groups = \"drop\"\n  )\n\n두 번째 지도를 작성한다.\n\nmy_map &lt;- tm_shape(seoul_gu) + tm_polygons(col = \"SGG1_NM\", border.col = NULL, legend.show = FALSE) +\n  tm_shape(seoul_dong_sra_25_2) + tm_borders(lwd = 1.5, col = \"gray20\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n세 번째 합역을 시행한다.\n\nseoul_sra_25_3 &lt;- utd.spatial.random.aggregation(seoul_dong_sn, 25)\nseoul_sra_25_3 &lt;- seoul_sra_25_3$sra\n\nseoul_dong_3 &lt;- seoul_dong |&gt; \n  left_join(seoul_sra_25_3, join_by(id == agg.id))\n\nseoul_dong_sra_25_3 &lt;- seoul_dong_3 |&gt; \n  group_by(seed.id) |&gt; \n  summarize(\n    geometry = st_union(geometry), \n    .groups = \"drop\"\n  )\n\n세 번째 지도를 작성한다.\n\nmy_map &lt;- tm_shape(seoul_gu) + tm_polygons(col = \"SGG1_NM\", border.col = NULL, legend.show = FALSE) +\n  tm_shape(seoul_dong_sra_25_3) + tm_borders(lwd = 1.5, col = \"gray20\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n네 번째 합역을 시행한다.\n\nseoul_dong_nb &lt;- poly2nb(seoul_dong, queen=FALSE)\nseoul_dong_sw &lt;- nb2listw(seoul_dong_nb, style=\"B\")\nseoul_dong_sn &lt;- listw2sn(seoul_dong_sw)\n\nseoul_sra_25_4 &lt;- utd.spatial.random.aggregation(seoul_dong_sn, 25)\nseoul_sra_25_4 &lt;- seoul_sra_25_4$sra\n\nseoul_dong_4 &lt;- seoul_dong |&gt; \n  left_join(seoul_sra_25_4, join_by(id == agg.id))\n\nseoul_dong_sra_25_4 &lt;- seoul_dong_4 |&gt; \n  group_by(seed.id) |&gt; \n  summarize(\n    geometry = st_union(geometry), \n    .groups = \"drop\"\n  )\n\n네 번째 지도를 작성한다.\n\nmy_map &lt;- tm_shape(seoul_gu) + tm_polygons(col = \"SGG1_NM\", border.col = NULL, legend.show = FALSE) +\n  tm_shape(seoul_dong_sra_25_4) + tm_borders(lwd = 1.5, col = \"gray20\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n레퍼런스 지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_dong) + tm_polygons(col = \"SGG1_NM\", legend.show = FALSE) +\n  tm_shape(seoul_gu) + tm_polygons(alpha = 0, lwd = 1.5, border.col = \"gray20\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n12.3.2 목적함수 합역 프로세스\nChatGPT의 도움을 받아 목적함수 합역 프로세스를 시도해 본다. 필수 패키지를 설치한다.\n\nlibrary(spdep)\nlibrary(GenSA)\nlibrary(readxl)\n\n전국 2020년 센서스용 읍면동 데이터를 불러와 인구 데이터와 조인한다.\n\nEMD_2020 &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2020_Census_Adj/EMD_2020_Census.shp\", options = \"ENCODING=CP949\")\n\nPop_SDGGEMD_2020 &lt;- read_excel(\"D:/My R/Korea Census Data Manipulation/1 Population Basic/DM_ADJ_Census_2020.xlsx\", sheet = 1)\n\nEMD_2020 &lt;- EMD_2020 |&gt; \n  mutate(\n    EMD_ID = as.numeric(EMD_ID)\n  )\n\nEMD_2020_pop &lt;- EMD_2020 |&gt; \n  left_join(\n    Pop_SDGGEMD_2020, join_by(EMD_ID == Code)\n  )\n\n서울만 골라낸다.\n\nseoul_2020_pop &lt;- EMD_2020_pop |&gt; \n  filter(\n    SD_NM == \"서울특별시\"\n  )\n\n인접성 행렬을 생성한다.\n\nnb &lt;- poly2nb(seoul_2020_pop)\nlistw &lt;- nb2listw(nb)\n\n최적화를 실행한다.\n\nset.seed(123)\n\n# 목적함수: 인구 균등화 + 인접성 제약 조건 반영\nobjective_function &lt;- function(partition) {\n  # 각 구역별로 인구 합계를 계산\n  zones &lt;- split(seoul_2020_pop$pop_t, partition)\n  zone_totals &lt;- sapply(zones, sum)\n  \n  # 인접성 위반 횟수 계산\n  penalty &lt;- 0\n  for (i in 1:length(nb)) {\n    neighbors &lt;- nb[[i]]  # i번 동의 이웃 동들\n    if (any(partition[i] != partition[neighbors])) {\n      penalty &lt;- penalty + 1  # 인접한 동이 다른 구역에 있으면 패널티 증가\n    }\n  }\n  \n  # 인구 표준편차 + 인접성 위반 패널티를 함께 고려\n  result &lt;- sd(zone_totals) + penalty * 10000  # 패널티 가중치 조절 가능\n  # print(result)\n  return(result)\n}\n\n# 3. 시뮬레이티드 어닐링 적용\nN &lt;- 10\ninitial_partition &lt;- as.numeric(sample(1:N, nrow(seoul_2020_pop), replace = TRUE))  # 초기 구역 설정을 numeric 타입으로 변환\nresult &lt;- GenSA(par = initial_partition, fn = objective_function, lower = rep(1, nrow(seoul_2020_pop)), upper = rep(N, nrow(seoul_2020_pop)))\n\n# 결과 출력\nresult$par &lt;- round(result$par)\nwrite_rds(result, \"optimal_zone_1.rds\")\n# seoul_2020_pop$zone &lt;- result$par  # 최적화된 구역 할당 결과\n\n결과를 확인한다.\n\noptimal_res &lt;- read_rds(\"optimal_zone_1.rds\")\nseoul_2020_pop$zone &lt;- optimal_res$par\n\n결과를 바탕으로 지오메트리를 생성한다.\n\nseoul_zone_10 &lt;- seoul_2020_pop |&gt; \n  group_by(zone) |&gt; \n  summarize(\n    geometry = st_union(geometry), \n    pop_total = sum(pop_t),\n    .groups = 'drop'\n  )\nseoul_zone_10$zone &lt;- as.character(seoul_zone_10$zone)\n\n지도를 생성한다. 그런데 결과는 썩 만족스럽지 않다. 연접성 요구가 거의 지켜지지 않고 있다.\n\ntm_shape(seoul_zone_10) + tm_polygons(col = \"zone\", style = \"cat\")",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>재분류</span>"
    ]
  },
  {
    "objectID": "vector_proximity.html",
    "href": "vector_proximity.html",
    "title": "\n10  근접성 분석\n",
    "section": "",
    "text": "10.1 버퍼링\n필수적인 패키지를 불러온다.\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(tmap)\nlibrary(readxl)\n서울시의 관련 데이터를 불러온다.\nseoul &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\")\nseoul_gu &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\")\nseoul_dong &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\")",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>근접성 분석</span>"
    ]
  },
  {
    "objectID": "vector_proximity.html#버퍼링",
    "href": "vector_proximity.html#버퍼링",
    "title": "\n10  근접성 분석\n",
    "section": "",
    "text": "10.1.1 포인트 버퍼링\n지하철 역세권을 나타내본다. 우선, 서울시 지하철역 지도를 생성한다.\n\nseoul_subst_coords &lt;- read_excel(\"D:/My R/GIS/서울시 역사마스터 정보.xlsx\") \n\nseoul_subst_coords |&gt; \n  st_as_sf(coords = c(\"위도\", \"경도\"), crs = 4326) |&gt; \n  st_transform(crs = st_crs(seoul_gu)) |&gt; \n  st_intersection(seoul) -&gt; seoul_subst\n\n역으로부터 반경 500미터 이내 지역을 선택한다.\n\nseoul_subst |&gt; \n  st_buffer(dist = 500) |&gt; \n  st_union() -&gt; seoul_subst_500\n\n지도를 생성한다.\n\nmy_map &lt;- tm_shape(seoul_gu) + tm_polygons(col = \"gray95\", lwd = 2) +\n  tm_shape(seoul_subst_500) + tm_polygons(col = \"gray50\", alpha = 0.5) +\n  tm_shape(seoul_subst) + tm_symbols(col = \"black\", size = 0.2) +\n  tm_legend(legend.position = c(0.75, 0.03)) +\n  tm_add_legend(type = \"symbol\", size = 0.70, col = \"black\", shape = 16, labels = \"Subway Stations\", title = \"\") +\n  tm_add_legend(type = \"fill\", size = 0.80, col = \"gray50\", labels = \"Buffering Distance: 500m\", title = \"\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Buffering: Points\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n10.1.2 라인 버퍼링\n데이터를 불러온다. 서울시의 도로망 데이터를 사용한다.\n\nseoul_sn &lt;- st_read(\"D:/My R/Vector Data Manipulation Korea/Korea_Transport_Database/seoul_link.shp\", options = \"ENCODING=CP949\")\nseoul_gu &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\")\n\n남부순환로로부터 1,000m 이내 지역에 대한 버퍼렁 만든다.\n\nnambu_cir &lt;- seoul_sn |&gt; \n  filter(\n    ROAD_NAME %in% c(\"남부순환로\")\n  )\nnambu_cir |&gt; \n  st_buffer(dist = 1000) |&gt; \n  st_union() -&gt; nambu_cir_1000\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_gu) + tm_polygons(col = \"gray98\", lwd = 2) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray50\") +\n  tm_shape(nambu_cir_1000) + tm_polygons(col = \"gray50\", alpha = 0.5) +\n  tm_shape(nambu_cir) + tm_lines(col = \"red\", lwd = 3) +\n  tm_legend(legend.position = c(0.75, 0.03)) +\n  tm_add_legend(type = \"line\", lwd = 2, col = \"red\", lty = 1, labels = \"Nambu Circular Rd.\", title = \"\") +\n  tm_add_legend(type = \"fill\", size = 0.80, col = \"gray50\", labels = \"Buffering Distance: 1km\", title = \"\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Buffering: Lines\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n10.1.3 폴리곤 버퍼링\n서울시 중구에 대해 버퍼링을 적용한다. 우선 중구를 선택한다.\n\njung_gu &lt;- seoul_gu |&gt; \n  filter(\n    SGG1_NM == \"중구\"\n  )\n\n중구로부터 2km, 5km, 10km의 버퍼를 생성한다.\n\njung_gu |&gt; \n  st_buffer(dist = 2000) |&gt; \n  st_union() -&gt; jung_gu_2000\njung_gu |&gt; \n  st_buffer(dist = 5000) |&gt; \n  st_union() -&gt; jung_gu_5000\njung_gu |&gt; \n  st_buffer(dist = 10000) |&gt; \n  st_union() -&gt; jung_gu_10000\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(jung_gu_10000) + tm_polygons(col = \"#fee8c8\") +\n  tm_shape(jung_gu_5000) + tm_polygons(col = \"#fdbb84\") +\n  tm_shape(jung_gu_2000) + tm_polygons(col = \"#e34a33\") +\n  tm_shape(seoul_gu, is.master = TRUE) + tm_borders() +\n  tm_shape(jung_gu) + tm_polygons(col = \"gray60\", lwd = 2) +\n  tm_legend(legend.position = c(0.75, 0.03)) +\n  tm_add_legend(type = \"fill\", size = 0.80, col = c(\"#e34a33\", \"#fdbb84\", \"#fee8c8\"), labels = c(\"2km\", \"2~5km\", \"5~10km\"), title = \"Buffering Distance\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Buffering: Polygons\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>근접성 분석</span>"
    ]
  },
  {
    "objectID": "vector_proximity.html#티센-폴로곤-thiessen-polygons",
    "href": "vector_proximity.html#티센-폴로곤-thiessen-polygons",
    "title": "\n10  근접성 분석\n",
    "section": "\n10.2 티센 폴로곤 Thiessen Polygons",
    "text": "10.2 티센 폴로곤 Thiessen Polygons\n스타벅스 매장에 대한 티센 폴리곤을 생성한다. 우선, 스타벅스 데이터를 불러온다.\n\nstarbucks_seoul_real &lt;- st_read(\"D:/My R/Vector Data Manipulation Korea/starbucks_seoul.shp\")\n\n티센 폴리곤을 생성한다.\n\nstarbucks_seoul_real |&gt; \n  st_union() |&gt; \n  st_voronoi(st_as_sfc(st_bbox(seoul))) |&gt; \n  st_cast() |&gt; \n  st_intersection(seoul) |&gt; \n  st_as_sf() |&gt; \n  st_cast(\"MULTIPOLYGON\") -&gt; starbucks_seoul_thiessen\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(starbucks_seoul_thiessen) + tm_polygons(col = \"gray95\") +\n  tm_shape(starbucks_seoul_real) + tm_dots(col = \"black\", size = 0.2, ) +\n  tm_legend(legend.position = c(0.75, 0.03)) +\n  tm_add_legend(type = \"symbol\", size = 0.80, col = \"black\", shape = 16, labels = \"Starbucks\", title = \"\") +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Thiessen Polygons\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) +\n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>10</span>  <span class='chapter-title'>근접성 분석</span>"
    ]
  },
  {
    "objectID": "vector_overlay.html",
    "href": "vector_overlay.html",
    "title": "\n13  중첩 분석\n",
    "section": "",
    "text": "13.1 중첩분석\n필수적인 데이터를 패키지를 불러온다.\nlibrary(tidyverse)\nlibrary(sf)\nlibrary(tmap)\nlibrary(readxl)\n서울의 관련 데이터를 불러온다.\nseoul &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\", options = \"ENCODING=CP949\")\nseoul_gu &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\", options = \"ENCODING=CP949\")\nseoul_dong &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\", options = \"ENCODING=CP949\")",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>중첩 분석</span>"
    ]
  },
  {
    "objectID": "vector_overlay.html#종류",
    "href": "vector_overlay.html#종류",
    "title": "\n13  중첩 분석\n",
    "section": "\n13.2 종류",
    "text": "13.2 종류\n\n13.2.1 포인트-인-폴리곤\n공간적 선택과 마찬가지로 관악구 내의 스타벅스만 선택하여 새로운 포인트 레이어를 생성한다. 우선 관악구를 선택하여 새로운 레이어를 만든다.\n\ngwanak_gu &lt;- seoul_gu |&gt; \n  filter(\n    SGG1_NM == \"관악구\"\n  )\n\n스타벅스 데이터를 불러온다.\n\nstarbucks_seoul_real &lt;- st_read(\"D:/My R/Vector Data Manipulation Korea/starbucks_seoul.shp\", options = \"ENCODING=CP949\")\n\n관악구에 포함되는 스타벅스 매장만 골라낸다.\n\nstarbucks_seoul_real |&gt; \n  st_intersection(gwanak_gu) -&gt; starbucks_gwanak\n\n지도를 생성한다. 공간적 선택의 지도와 사실상 동일하다.\n\nmy_map &lt;- tm_shape(seoul_gu) + tm_polygons(col = \"gray98\", lwd = 1) +\n  tm_shape(gwanak_gu) + tm_polygons(col = \"gray70\") +\n  tm_shape(starbucks_seoul_real) + tm_dots(col = \"black\", size = 0.2) +\n  tm_shape(starbucks_gwanak) + tm_dots(col = \"red\", size = 0.2) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Overlay Analysis: Point-in-Polygon\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n13.2.2 라인-온-폴리곤\n공간적 선택과 마찬가지로 중구 내부의 도로망만을 선택하여 폴리라인 레이어를 생성한다. 우선 서울시 도로망 데이터를 불러온다.\n\nseoul_sn &lt;- st_read(\"D:/My R/Vector Data Manipulation Korea/Korea_Transport_Database/seoul_link.shp\", options = \"ENCODING=CP949\")\n\n중구만 선택한다.\n\njung_gu &lt;- seoul_gu |&gt; \n  filter(\n    SGG1_NM == \"중구\"\n  )\n\n중구와 인터섹터의 관계에 있는 도로만 선택한다. 선택이 아니라 클립에 해당한다는 사실에 유의한다.\n\nseoul_sn |&gt; \n  st_intersection(jung_gu) -&gt; jung_gu_sn\n\n지도를 생성한다.\n\nmy_map &lt;- tm_shape(seoul_gu, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 2) +\n  tm_shape(jung_gu) + tm_polygons(col = \"gray70\", border.col = \"gray10\", lwd = 2) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray70\") +\n  tm_shape(jung_gu_sn) + tm_lines(col = \"red\", lwd = 2) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Overlay Analysis: Line-on-Polygon\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n중구만 확대한 지도를 제작한다. 공간적 선택의 결과와 다름을 이해한다.\n\nmy_map &lt;- tm_shape(jung_gu) + tm_polygons(col = \"gray70\", border.col = \"gray10\", lwd = 2) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray70\") +\n  tm_shape(jung_gu_sn) + tm_lines(col = \"red\", lwd = 2) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) + \n  tm_scale_bar(breaks = seq(0, 2.5, 0.5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>13</span>  <span class='chapter-title'>중첩 분석</span>"
    ]
  },
  {
    "objectID": "part_5.html",
    "href": "part_5.html",
    "title": "래스터-기반 GIS 오퍼레이션",
    "section": "",
    "text": "이 파트에서는 다음의 내용을 다룬다.\n\n개요\n일반화(generalization)\n측정(measurement)\n재계산(recalculation)\n재분류(reclassification)\n근접성 분석(proximity analysis)\n중첩 분석(overlay analysis)",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션"
    ]
  },
  {
    "objectID": "part_5.html#주요-내용",
    "href": "part_5.html#주요-내용",
    "title": "래스터-기반 GIS 오퍼레이션",
    "section": "",
    "text": "일반화(generalization)\n측정(measurement)\n재계산(recalculation)\n재분류(reclassification)\n근접성 분석(proximity analysis)\n중첩 분석(overlay analysis)",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션"
    ]
  },
  {
    "objectID": "part_5.html#래스터-기초",
    "href": "part_5.html#래스터-기초",
    "title": "래스터-기반 GIS 오퍼레이션",
    "section": "래스터 기초",
    "text": "래스터 기초\n래스터 좌표계\n래스터 좌표계는 기본적으로 그리드 좌표계(grid coordinate system)을 사용하지만, 빠른 검색을 위해 셀위치 좌표계(cell position coordinate system)도 함께 사용한다.\n그리드 좌표계의 원점(0, 0)은 CRS에 의거해 주어지는 것으로 서남쪽 어딘가(보통 해당 그리드 내부에 있지 않음) 존재한다. 그러므로 동쪽과 북쪽으로 갈수록 좌표값이 증가한다. 해당 그리드의 최서남단 꼭지점에 동거와 북거가 가장 작은 지점이 존재하고, 이것을 해당 래스터의 그리드 원점이라고 부른다. 개별 래스터 데이터는 그리드 영역(extent) 정보를 가지고 있는데, 동거의 최소값과 최대값, 북거의 최소값과 최대값이 주어진다. 이 정보와 셀 크기(그리드 셀의 한 변의 길이)를 이용해 래스터 내부의 위치(주로, 개별 그리드 셀의 네 꼭지점 좌표와 셀 중심점 좌표)에 대한 좌표값을 알 수 있다.\n\n셀위치 좌표계의 좌표값은 지점에 대한 것이 아니라 그리드 셀 전체의 인덱스로, 해당 그리드 내에서만 통용된다. 최서북단 그리드가 원점 구실을 하고, 그 그리드 셀의 좌표값은 (0, 0)이다. 그것으로부터 동쪽으로 갈수록 셀 좌표값이 1씩 증가하고, 남쪽으로 갈수록 셀 좌표값이 1씩 증가한다. 개별 그리드 셀의 좌표값은 y 축을 먼저 읽고 다음에 x 축을 읽는 방식을 취한다. 그러므로 원점 셀 바로 아래에 있는 셀의 좌표값은 (1, 0)이다.\n\n여기에 덧붙여 셀 일련번호(cell number)라는 것이 있다. 이것은 셀마다 인덱스 번호를 부여한 것인데, 좌상끝에 위치한 셀에 1을 부여하고, 행별로 일련번호를 붙여나가, 우하끝에 위치한 셀에 마지막 번호를 부여한 것이다.",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션"
    ]
  },
  {
    "objectID": "part_5.html#래스터-레이어의-사례-서울시-dem",
    "href": "part_5.html#래스터-레이어의-사례-서울시-dem",
    "title": "래스터-기반 GIS 오퍼레이션",
    "section": "래스터 레이어의 사례: 서울시 DEM",
    "text": "래스터 레이어의 사례: 서울시 DEM\n데이터 불러오기\n필수적인 패키지를 설치한다. 래스터 분석을 위한 기본 패키지를 terra를 사용한다.\n\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(sf)\nlibrary(tmap)\n\n서울에 대한 SRTM 기반 DEM 데이터를 불러온다.\n\ndem_seoul &lt;- rast(\"D:/My R/World Data Manupulation/USGS EarthExplorer/srtm_seoul.tif\")\ndem_seoul_mask &lt;- rast(\"D:/My R/World Data Manupulation/USGS EarthExplorer/srtm_seoul_mask.tif\")\n\n서울의 행정구역 바운더리 파일을 불러온다.\n\nseoul &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\")\nseoul_gu &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\")\nseoul_dong &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\")\n\n기본적인 지오메트리 확인\n기본적인 지오메트리 파라미터값을 알아본다.\n\ndem_seoul\n\nclass       : SpatRaster \ndimensions  : 1169, 1428, 1  (nrow, ncol, nlyr)\nresolution  : 25.92782, 25.92782  (x, y)\nextent      : 935046.3, 972071.2, 1936672, 1966982  (xmin, xmax, ymin, ymax)\ncoord. ref. : +proj=tmerc +lat_0=38 +lon_0=127.5 +k=0.9996 +x_0=1000000 +y_0=2000000 +ellps=GRS80 +units=m +no_defs \nsource      : srtm_seoul.tif \nname        : n37_e126_1arc_v3 \nmin value   :        -31.52316 \nmax value   :        811.87531 \n\n\n개별 파라미터 값을 다음과 같이 알아본다.\n\next(dem_seoul) # 범역\n\nSpatExtent : 935046.294557821, 972071.227871716, 1936672.39531736, 1966982.02209884 (xmin, xmax, ymin, ymax)\n\n\n\nres(dem_seoul) # 셀 크기\n\n[1] 25.92782 25.92782\n\n\n\ndim(dem_seoul) # 가로 세로 그리드 셀 수\n\n[1] 1169 1428    1\n\n\n\nncell(dem_seoul) # 총 그리드 셀 수\n\n[1] 1669332\n\n\n\npersp(dem_seoul) # 3D 시각화\n\n\n\n\n\n\n\n간단히 그려본다.\n\nqtm(dem_seoul) + qtm(seoul, fill = NULL)\n\n\n\n\n\n\n\n지도를 작성한다.\n\nmy_map &lt;- tm_shape(dem_seoul, raster.downsample = FALSE) + \n  tm_raster(style = \"cont\", palette = c(\"forestgreen\",\"yellow\",\"tan\",\"brown\"), title = \"Elev.(m)\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.06), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.07, 0.04, 0.06, 0.04), \n            title = \"DEM for Seoul\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n래스터 좌표계의 왕래\n셀 일련번호와 셀위치 좌표계를 왕래할 수 있다. 우선 셀 일련번호를 알고 있는 경우, 그것의 셀위치 좌표의 행값을 알아내려면 다음과 같이 하면 된다. 10,000번째 셀의 셀위치 좌표계의 행값이 8, 열값이 4임을 알 수 있다. 그러므로 행위치 좌표값은 (8, 4)이다.\n\nrowFromCell(dem_seoul, 10000)\n\n[1] 8\n\n\n\ncolFromCell(dem_seoul, 10000)\n\n[1] 4\n\n\n거꾸로 셀위치 좌표값을 알고 있는 경우, 그것의 셀 일련번호를 알아내려면 다음과 같이 하면 된다.\n\ncellFromRowCol(dem_seoul, 8, 4)\n\n[1] 10000\n\n\n또한 셀 일련번호와 그리드 좌표계를 왕래할 수 있다. 우선 셀 일련번호를 알고 있는 경우, 그것의 셀위치 좌표의 행값을 알아내려면 다음과 같이 하면 된다.\n\nxyFromCell(dem_seoul, 10000)\n\n          x       y\n[1,] 935137 1966788\n\n\n거꾸로 그리드 좌표값을 알고 있는 경우, 그것의 셀 일련번호를 알아내려면 다음과 같이 하면 된다.\n\ncellFromXY(dem_seoul, cbind(935137, 1966788))\n\n[1] 10000\n\n\n또한 셀위치 좌표계와 그리드 좌표계를 왕래할 수 있다. 우선 그리드의 x-좌표를 알고 있는 경우, 그것의 셀위치 좌표의 열값을 알아내려면 다음과 같이 하면 된다.\n\ncolFromX(dem_seoul, 935137)\n\n[1] 4\n\n\n그리드의 y-좌표를 알고 있는 경우, 그것의 셀위치 좌표의 행값을 알아내려면 다음과 같이 하면 된다.\n\nrowFromY(dem_seoul, 1966788)\n\n[1] 8\n\n\n셀 값의 확인\nextract() 함수를 이용하면 셀 값을 얻을 수 있다. 가장 단순한 방법은 셀 일련번호를 아는 경우이다.\n\ndem_seoul |&gt; \n  extract(10000)\n\n  n37_e126_1arc_v3\n1         36.23445\n\n\n다음으로 그리드 좌표를 아는 경우는 다음과 같이 구할 수 있다\n\ndem_seoul |&gt;  \n  extract(cbind(935137, 1966788))\n\n  n37_e126_1arc_v3\n1         36.23445\n\n\n셀위치 좌표를 아는 경우 막바로 구할 수 없고, 먼저 셀 일련번호로 전환한 후 구할 수 있다.\n\ncell_num &lt;- cellFromRowCol(dem_seoul, 8, 4)\ndem_seoul |&gt; \n  extract(cell_num)\n\n  n37_e126_1arc_v3\n1         36.23445\n\n\n요약 통계량\n최소값과 최대값은 다음과 같이 구할 수 있다.\n\nminmax(dem_seoul)\n\n    n37_e126_1arc_v3\nmin        -31.52316\nmax        811.87531\n\n\n다음과 같이 하면 최소값과 해당 셀의 일련번호를 구할 수 있다. 그런데 에러가 난다.\n\nwhere.min(dem_seoul)\n\n     layer cell value\n\n\n다음과 같이 하면 최대값과 해당 셀의 일련번호를 구할 수 있다.\n\nwhere.max(dem_seoul)\n\n     layer   cell    value\n[1,]     1 259198 811.8753\n\n\n이 정보를 바탕으로 최대값을 보이는 지점의 좌표값을 구할 수 있다.\n\ndem_max_xy &lt;- xyFromCell(dem_seoul, where.max(dem_seoul)[,2])\n\n벡터 포인트 객체로 만들 수 있다.\n\ndem_max_sf &lt;- st_sfc(geometry = st_point(dem_max_xy), crs = st_crs(seoul))\nqtm(dem_max_sf)",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션"
    ]
  },
  {
    "objectID": "raster_generalization.html",
    "href": "raster_generalization.html",
    "title": "\n15  일반화\n",
    "section": "",
    "text": "15.1 준비\n필수적인 패키지를 설치한다. 래스터 분석을 위한 기본 패키지를 terra를 사용한다.\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(sf)\nlibrary(tmap)\n서울에 대한 SRTM 기반 DEM 데이터를 불러온다.\ndem_seoul &lt;- rast(\"D:/My R/World Data Manupulation/USGS EarthExplorer/srtm_seoul.tif\")\ndem_seoul_mask &lt;- rast(\"D:/My R/World Data Manupulation/USGS EarthExplorer/srtm_seoul_mask.tif\")\n서울의 행정구역 바운더리 파일을 불러온다.\nseoul &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\")\nseoul_gu &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\")\nseoul_dong &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\")",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>일반화</span>"
    ]
  },
  {
    "objectID": "raster_generalization.html#애그리게이트aggregate-병합",
    "href": "raster_generalization.html#애그리게이트aggregate-병합",
    "title": "\n15  일반화\n",
    "section": "\n15.2 애그리게이트(aggregate, 병합)",
    "text": "15.2 애그리게이트(aggregate, 병합)\naggregate() 함수를 이용하여 실행한다.\n\ndem_seoul |&gt; \n  aggregate(fact = 10, fun = mean) -&gt; dem_seoul_agg\n\n기본적인 지오메트리 파라미터값을 알아본다.\n\ndem_seoul_agg\n\nclass       : SpatRaster \ndimensions  : 117, 143, 1  (nrow, ncol, nlyr)\nresolution  : 259.2782, 259.2782  (x, y)\nextent      : 935046.3, 972123.1, 1936646, 1966982  (xmin, xmax, ymin, ymax)\ncoord. ref. : KGD2002 / Unified CS (EPSG:5179) \nsource(s)   : memory\nname        : n37_e126_1arc_v3 \nmin value   :            3.000 \nmax value   :          715.111 \n\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(dem_seoul_agg, raster.downsample = FALSE) + \n  tm_raster(style = \"cont\", palette = c(\"forestgreen\",\"yellow\",\"tan\",\"brown\"), title = \"Elev.(m)\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.06), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.07, 0.04, 0.06, 0.04), \n            title = \"Generalization: Aggregate\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>15</span>  <span class='chapter-title'>일반화</span>"
    ]
  },
  {
    "objectID": "raster_measurement.html",
    "href": "raster_measurement.html",
    "title": "\n16  측정\n",
    "section": "",
    "text": "16.1 준비\n필수적인 패키지를 설치한다. 래스터 분석을 위한 기본 패키지를 raster를 사용한다.\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(sf)\nlibrary(tmap)\n서울에 대한 SRTM 기반 DEM 데이터를 불러온다.\ndem_seoul &lt;- rast(\"D:/My R/World Data Manupulation/USGS EarthExplorer/srtm_seoul.tif\")\ndem_seoul_mask &lt;- rast(\"D:/My R/World Data Manupulation/USGS EarthExplorer/srtm_seoul_mask.tif\")\n서울의 행정구역 바운더리 파일을 불러온다.\nseoul &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\")\nseoul_gu &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\")\nseoul_dong &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\")",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>측정</span>"
    ]
  },
  {
    "objectID": "raster_measurement.html#기본-원리",
    "href": "raster_measurement.html#기본-원리",
    "title": "\n16  측정\n",
    "section": "\n16.2 기본 원리",
    "text": "16.2 기본 원리",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>측정</span>"
    ]
  },
  {
    "objectID": "raster_measurement.html#조널-지오메트리",
    "href": "raster_measurement.html#조널-지오메트리",
    "title": "\n16  측정\n",
    "section": "\n16.3 조널 지오메트리",
    "text": "16.3 조널 지오메트리\n\n16.3.1 면적\n우선 서울구에 대한 래스터 레이어를 생성한다.\n\nseoul_gu |&gt; \n  rasterize(dem_seoul_mask, field = \"SGG1_CD\") -&gt; seoul_gu_r\n\n구에 해당되는 셀에 해당 구의 면적을 할당하여 새로운 래이어를 생성한다. cellSize() 함수를 통해 모든 셀에 해당 셀의 면적이 들어가 있는 래스터를 생성한 후, zonal() 함수를 적용한다. as.raster 아규먼트를 통해 래스터 레이어를 생성하는 것이 키포인트이다.\n\nseoul_gu_r |&gt; \n  cellSize()/1000000 -&gt; seoul_gu_area\n\nseoul_gu_area |&gt; \n  zonal(seoul_gu_r, fun = \"sum\", na.rm = TRUE, as.raster = TRUE) -&gt; seoul_gu_area_r\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_gu_area_r, raster.downsample = FALSE) + \n  tm_raster(style = \"cont\", palette = \"Purples\", title = expression(\"Area(km\"^2*\")\")) +\n  # tm_shape(seoul_gu) + tm_borders(col = \"gray80\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Measurement: Area\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n16.3.2 주변길이\n약간의 계산이 필요하다. 속도가 상당히 느리다. 성공은 했지만, 다른 방법이 있을 듯 하다.\n\nseoul |&gt; \n  rasterize(dem_seoul_mask, field = \"SD_CD\") -&gt; seoul_r \n\nseoul_perimeter_r &lt;- seoul_gu_r\nregion_ids &lt;- unique(values(seoul_gu_r))\nregion_ids &lt;- region_ids[!is.na(region_ids)]\n\nfor (region_id in region_ids) {\n  region_r &lt;- seoul_gu_r\n  region_r[region_r != region_id] &lt;- NA # 구별로 완전히 독립시킨다. 그래야만 boundaries() 함수가 제대로 작동\n  region_boundary &lt;- boundaries(region_r, classes = TRUE)\n  perimeter_cells &lt;- sum(values(region_boundary) == 1, na.rm = TRUE)\n  cell_res &lt;- res(seoul_gu_r)[1]  \n  perimeter &lt;- perimeter_cells * cell_res / 1000\n  region_r_r &lt;- seoul_gu_r == region_id # 값을 셀로 옮기려면 서울 전체가 살아있는 raster가 존재해야 함.\n  seoul_perimeter_r[region_r_r] &lt;- perimeter\n}\n\nwriteRaster(seoul_perimeter_r, \"seoul_perimeter_r.tif\", overwrite = TRUE)\n\n주변 길이에 데이터를 불러온다.\n\nseoul_perimeter_r &lt;- rast(\"seoul_perimeter_r.tif\")\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_perimeter_r, raster.downsample = FALSE) + \n  tm_raster(style = \"cont\", palette = \"Purples\", title = \"Perimeter(km)\") +\n  # tm_shape(seoul_gu) + tm_borders(col = \"gray80\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.02), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Measurement: Perimeter\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>측정</span>"
    ]
  },
  {
    "objectID": "raster_recalculation.html",
    "href": "raster_recalculation.html",
    "title": "\n17  재계산\n",
    "section": "",
    "text": "17.1 준비\n필수적인 패키지를 설치한다. 래스터 분석을 위한 기본 패키지를 raster를 사용한다.\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(sf)\nlibrary(tmap)\n서울에 대한 SRTM 기반 DEM 데이터를 불러온다.\ndem_seoul &lt;- rast(\"D:/My R/World Data Manupulation/USGS EarthExplorer/srtm_seoul.tif\")\ndem_seoul_mask &lt;- rast(\"D:/My R/World Data Manupulation/USGS EarthExplorer/srtm_seoul_mask.tif\")\n서울의 행정구역 바운더리 파일을 불러온다.\nseoul &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\")\nseoul_gu &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\")\nseoul_dong &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\")",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>재계산</span>"
    ]
  },
  {
    "objectID": "raster_recalculation.html#정의와-종류",
    "href": "raster_recalculation.html#정의와-종류",
    "title": "\n17  재계산\n",
    "section": "\n17.2 정의와 종류",
    "text": "17.2 정의와 종류",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>재계산</span>"
    ]
  },
  {
    "objectID": "raster_recalculation.html#수학적-연산",
    "href": "raster_recalculation.html#수학적-연산",
    "title": "\n17  재계산\n",
    "section": "\n17.3 수학적 연산",
    "text": "17.3 수학적 연산\n\n17.3.1 산술 연산자\n루트값을 계산한다.\n\ndem_seoul |&gt; \n  sqrt() -&gt; dem_seoul_sqrt\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(dem_seoul_sqrt, raster.downsample = FALSE) + \n  tm_raster(style = \"cont\", palette = \"Oranges\", title = \"Elev(sqrt)\", legend.show = TRUE) +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.07, 0.04, 0.06, 0.04), \n            title = \"Recalculation: Local(sqrt)\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n17.3.2 로그 연산자\n자연로그값을 산출한다.\n\ndem_seoul |&gt; \n  log() -&gt; dem_seoul_log\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(dem_seoul_log, raster.downsample = FALSE) + \n  tm_raster(style = \"cont\", palette = \"Blues\", title = \"Elev(log)\", legend.show = TRUE) +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.07, 0.04, 0.06, 0.04), \n            title = \"Recalculation: Local(log)\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>재계산</span>"
    ]
  },
  {
    "objectID": "raster_recalculation.html#포컬-통계",
    "href": "raster_recalculation.html#포컬-통계",
    "title": "\n17  재계산\n",
    "section": "\n17.4 포컬 통계",
    "text": "17.4 포컬 통계\n\n17.4.1 평균\n포컬 평균을 계산한다.\n\ndem_seoul |&gt; \n  focal(w = 3, fun = \"mean\") -&gt; dem_seoul_focal_mean\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(dem_seoul_focal_mean, raster.downsample = FALSE) + \n  tm_raster(style = \"cont\", palette = c(\"forestgreen\",\"yellow\",\"tan\",\"brown\"), title = \"Elev.(m)\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.06), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.07, 0.04, 0.06, 0.04), \n            title = \"Recalculation: Focal(Mean)\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n17.4.2 표준편차\n포컬 표준편차를 계산한다.\n\ndem_seoul |&gt; \n  focal(w = 3, fun = sd) -&gt; dem_seoul_focal_sd \n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(dem_seoul_focal_sd, raster.downsample = FALSE) + \n  tm_raster(style = \"cont\", palette = \"PuRd\", title = \"Std. Dev.\", legend.show = TRUE) +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.07, 0.04, 0.06, 0.04), \n            title = \"Recalculation: Focal(Standard Deviation)\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>재계산</span>"
    ]
  },
  {
    "objectID": "raster_recalculation.html#조널-통계",
    "href": "raster_recalculation.html#조널-통계",
    "title": "\n17  재계산\n",
    "section": "\n17.5 조널 통계",
    "text": "17.5 조널 통계\n서울시의 구와 동을 래스터화한다.\n\nseoul_gu |&gt; \n  mutate(\n    SGG1_CD = as.numeric(SGG1_CD)\n  ) |&gt; \n  rasterize(dem_seoul_mask, field = \"SGG1_CD\") -&gt; seoul_gu_r\n\nseoul_dong |&gt; \n  mutate(\n    EMD_ID = as.numeric(EMD_ID)\n  ) |&gt; \n  rasterize(dem_seoul_mask, field = \"SGG1_CD\") -&gt; seoul_dong_r\n\n\n17.5.1 평균\n서울시 구와 동의 조널 평균을 계산한다. zonal() 함수의 as.raster 아규먼트가 중요하다.\n\ndem_seoul_mask |&gt; \n  zonal(seoul_gu_r, fun = \"mean\", na.rm = TRUE, \n        as.raster = TRUE) -&gt; dem_seoul_gu_mask_zonal_mean\ndem_seoul_mask |&gt; \n  zonal(seoul_dong_r, fun = \"mean\", na.rm = TRUE, \n        as.raster = TRUE) -&gt; dem_seoul_dong_mask_zonal_mean\n\n동에 대한 지도를 제작한다.\n\nmy_map &lt;- tm_shape(dem_seoul_dong_mask_zonal_mean) + tm_raster(style = \"cont\", palette = c(\"forestgreen\",\"yellow\",\"tan\",\"brown\"), title = \"Elevation(m)\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.07, 0.04, 0.04, 0.04), \n            title = \"Recalculation: Zonal(Mean)\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n17.5.2 표준편차\n서울시 구와 동의 조널 표준편차를 계산한다.\n\ndem_seoul_mask |&gt; \n  zonal(seoul_gu_r, fun = \"sd\", na.rm = TRUE, as.raster = TRUE) -&gt; dem_seoul_gu_mask_zonal_sd\ndem_seoul_mask |&gt; \n  zonal(seoul_dong_r, fun = \"sd\", na.rm = TRUE, as.raster = TRUE) -&gt; dem_seoul_dong_mask_zonal_sd\n\n동에 대한 지도를 제작한다.\n\nmy_map &lt;- tm_shape(dem_seoul_dong_mask_zonal_sd) + tm_raster(style = \"cont\", palette = \"PuRd\", title = \"Std. Dev.\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.07, 0.04, 0.04, 0.04), \n            title = \"Recalculation: Zonal(Standard Deviation)\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n17.5.3 벡터-온-래스터\nDEM의 값을 구와 동으로 전이시킨다.\n\ndem_seoul |&gt; \n  extract(seoul_dong, fun = \"mean\") |&gt; \n  pull() -&gt; seoul_dong$elev\ndem_seoul |&gt; \n  extract(seoul_gu, fun = \"mean\") |&gt; \n  pull() -&gt; seoul_gu$elev\n\n동에 대한 지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_dong) + \n  tm_polygons(col = \"elev\", style = \"cont\", palette = c(\"forestgreen\",\"yellow\",\"tan\",\"brown\"), title = \"Elevation(m)\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.07, 0.04, 0.04, 0.04), \n            title = \"Recalculation: vector-on-raster\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n벡터 동경계 지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_dong) + tm_polygons(col = \"white\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.07, 0.04, 0.06, 0.04), \n            title = \"Boundary of Dongs\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>17</span>  <span class='chapter-title'>재계산</span>"
    ]
  },
  {
    "objectID": "raster_proximity.html",
    "href": "raster_proximity.html",
    "title": "\n19  근접성 분석\n",
    "section": "",
    "text": "19.1 준비\n필수적인 패키지를 설치한다. 래스터 분석을 위한 기본 패키지를 terra를 사용한다.\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(sf)\nlibrary(tmap)\n서울에 대한 SRTM 기반 DEM 데이터를 불러온다.\ndem_seoul &lt;- rast(\"D:/My R/World Data Manupulation/USGS EarthExplorer/srtm_seoul.tif\")\ndem_seoul_mask &lt;- rast(\"D:/My R/World Data Manupulation/USGS EarthExplorer/srtm_seoul_mask.tif\")\n서울의 행정구역 바운더리 파일을 불러온다.\nseoul &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\")\nseoul_gu &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\")\nseoul_dong &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\")\n서울의 소방서 위치를 불러온다.\nseoul_sobang &lt;- st_read(\"D:/My R/Vector Data Manipulation Korea/Seoul_Data_Plaza/sobang_station_seoul.shp\", options = \"ENCODING=CP949\")",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>근접성 분석</span>"
    ]
  },
  {
    "objectID": "raster_proximity.html#정의와-산출-레이어",
    "href": "raster_proximity.html#정의와-산출-레이어",
    "title": "\n19  근접성 분석\n",
    "section": "\n19.2 정의와 산출 레이어",
    "text": "19.2 정의와 산출 레이어",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>근접성 분석</span>"
    ]
  },
  {
    "objectID": "raster_proximity.html#유클리드-거리",
    "href": "raster_proximity.html#유클리드-거리",
    "title": "\n19  근접성 분석\n",
    "section": "\n19.3 유클리드 거리",
    "text": "19.3 유클리드 거리\n\n19.3.1 거리\n소방서로부터의 유클리드 거리를 계산한다. distance() 함수에서 첫 번째 인수가 raster이면 모든 NA셀(소방서가 없는 셀)로부터 비NA 셀(소방서가 위치한 셀) 중 가장 가까이 있는 것까지의 거리를 계산해준다. 첫 번째 인수가 vector이면 모든 피처간의 거리 매트릭스를 산출해 준다.\n\nseoul_sobang |&gt; \n  rasterize(dem_seoul, field = \"ID\") -&gt; seoul_sobang_r\nseoul_sobang_r |&gt; \n  distance() / 1000 -&gt; seoul_sobang_dist_1\nseoul_sobang_dist_1 |&gt; \n  mask(seoul) -&gt; seoul_sobang_dist_1_mask\n\n지도를 제작한다. 먼저 연속형 컬러 스킴을 사용하여 제작한다.\n\nmy_map &lt;- tm_shape(seoul_sobang_dist_1_mask, raster.downsample = FALSE) + tm_raster(style = \"cont\", palette = \"GnBu\", title = \"Distance(km)\") +\n  tm_shape(seoul_sobang) + tm_symbols() +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Euclidean Distance from Fire Stations\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n이번에는 단계구분형 컬러 스킴을 사용하여 제작한다.\n\nmy_map &lt;- tm_shape(seoul_sobang_dist_1_mask, raster.downsample = FALSE) + tm_raster(style = \"fixed\", breaks = c(0, 1, 2, 3, 4, 5, Inf), palette = \"GnBu\", title = \"Distance(km)\") +\n  tm_shape(seoul_sobang) + tm_symbols() +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Euclidean Distance from Fire Stations\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n19.3.2 할당\n함수를 만든다. raster 패키지의 rasterToPoints() 함수가 terra 패키지에서는 as.points() 함수로 바뀌었다.\n\n# snu.rasterAlloc &lt;- function(feature, rastermask){\n#   p &lt;- st_as_sf(as.points(rastermask))\n#   p &lt;- st_transform(p, crs = st_crs(feature))\n#   p$indx &lt;- st_nearest_feature(st_geometry(p), st_geometry(feature))\n#   output &lt;- rasterize(p, rastermask, field = \"indx\")\n#   return(output)\n# }\n\nsnu.rasterAlloc &lt;- function(feature, rastermask){\n  rastermask |&gt; \n    as.points() |&gt; \n    st_as_sf() |&gt; \n    st_transform(crs = st_crs(feature)) -&gt; p\n  p |&gt; \n    st_geometry() |&gt; \n    st_nearest_feature(st_geometry(feature)) -&gt; p_index\n  p |&gt; \n    mutate(\n      index = p_index\n    ) |&gt; \n    rasterize(rastermask, field = \"index\") -&gt; output\n  return(output)\n}\n\n할당면을 생성한다.\n\nseoul_sobang |&gt; \n  snu.rasterAlloc(dem_seoul_mask) -&gt; seoul_sobang_allo\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_sobang_allo, raster.downsample = FALSE) + tm_raster(style = \"cat\", palette = \"Set3\", legend.show = FALSE) +\n  tm_shape(seoul_sobang) + tm_symbols() +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Euclidean Distance: Allocation Layer for Fire Stations\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n티센 폴리곤을 생성하여 비교해 본다.\n\nseoul_sobang |&gt; \n  st_union() |&gt; \n  st_voronoi(st_as_sfc(st_bbox(seoul))) |&gt; \n  st_cast() |&gt; \n  st_intersection(seoul) |&gt; \n  st_as_sf() |&gt; \n  st_cast(\"POLYGON\") -&gt; seoul_sobang_thiessen\n\nseoul_sobang_thiessen |&gt; \n  st_intersects(seoul_sobang) |&gt; \n  unlist() -&gt; sel_index\nseoul_sobang_thiessen |&gt; \n  mutate(\n    ID = as.character(sel_index)\n  ) -&gt; seoul_sobang_thiessen\n\n# seoul_sobang_thiessen$ID &lt;- unlist(st_intersects(seoul_sobang_thiessen, seoul_sobang)) \n# seoul_sobang_thiessen &lt;- aggregate(seoul_sobang_thiessen, by = list(seoul_sobang_thiessen$ID), FUN = sum)\n# seoul_sobang_thiessen$ID &lt;- as.factor(seoul_sobang_thiessen$ID) \n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul) + tm_polygons(col = \"gray98\", border.col = \"gray30\") +\n  tm_shape(seoul_sobang_thiessen) + tm_polygons(col = \"ID\", palette = \"Set3\", lwd = 1, border.col = \"gray20\", legend.show = FALSE) +\n  tm_shape(seoul_sobang) + tm_symbols() +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Thiessen Polygons for Fire Stations\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>근접성 분석</span>"
    ]
  },
  {
    "objectID": "raster_proximity.html#기능적-거리",
    "href": "raster_proximity.html#기능적-거리",
    "title": "\n19  근접성 분석\n",
    "section": "\n19.4 기능적 거리",
    "text": "19.4 기능적 거리\nmovecost 패키지를 사용한다.\n\n# library(devtools)\n# install_github(\"cran/movecost\")\nlibrary(movecost)\n\n\n19.4.1 거리\nmovecost() 함수를 이용하여 기능적 거리를 계산한다.\n\n# result_cost &lt;- movecost(dem_seoul_mask, origin = as_Spatial(seoul_sobang), funct = \"wcs\")\n# seoul_sobang_cost &lt;- result_cost$accumulated.cost.raster/1000\n# crs(seoul_sobang_cost) &lt;- \"+proj=tmerc +lat_0=38 +lon_0=127.5 +k=0.9996 +x_0=1000000 +y_0=2000000 +ellps=GRS80 +units=m\"\n# writeRaster(seoul_sobang_cost, \"seoul_sobang_cost\", format=\"GTiff\", overwrite = TRUE)\nseoul_sobang_cost &lt;- rast(\"seoul_sobang_cost.tif\")\n\n지도를 제작한다. 먼저 연속형 컬러 스킴을 사용하여 제작한다.\n\nmy_map &lt;- tm_shape(seoul_sobang_cost, raster.downsample = FALSE) + tm_raster(style = \"cont\", palette = \"GnBu\", title = \"Least Cost\") +\n  tm_shape(seoul_sobang) + tm_symbols() +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Functional Distance from Fire Stations\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n이번에는 단계구분형 컬러 스킴을 사용하여 제작한다.\n\nmy_map &lt;- tm_shape(seoul_sobang_cost, raster.downsample = FALSE) + tm_raster(style = \"fixed\", breaks = c(0, 1, 2, 3, 4, 5, Inf), palette = \"GnBu\", title = \"Least Cost\") +\n  tm_shape(seoul_sobang) + tm_symbols() +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Functional Distance from Fire Stations\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n19.4.2 할당\nmovealloc() 함수를 활용하여 할당 레이어를 계산한다.\n\n# result_allo &lt;- movealloc(dem_seoul_mask, as_Spatial(seoul_sobang), funct = \"wcs\")\n# seoul_sobang_allo_cost &lt;- result_allo$cost.allocation.raster\n# crs(seoul_sobang_allo_cost) &lt;- \"+proj=tmerc +lat_0=38 +lon_0=127.5 +k=0.9996 +x_0=1000000 +y_0=2000000 +ellps=GRS80 +units=m\"\n# writeRaster(seoul_sobang_allo_cost, \"seoul_sobang_allo_cost\", format=\"GTiff\", overwrite = TRUE)\nseoul_sobang_allo_cost &lt;- rast(\"seoul_sobang_allo_cost.tif\")\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_sobang_allo_cost, raster.downsample = FALSE) + tm_raster(style = \"cat\", palette = \"Set3\", legend.show = FALSE) +\n  tm_shape(seoul_sobang) + tm_symbols() +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Functional Distance: Allocation for Fire Stations\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n19.4.3 또 다른 방법\n위의 예시와 달리 topoDistance 패키지를 활용하여 거리면을 생성해 본다. 이 패키지는 DEM 상에서의 거리를 계산해 주는데, 일반적인 GIS 프로그램에 사용되는 지형 거리 혹은 표면 거리와 달리 일종의 최소비용경로 개념을 상정한다. 보통은 두 지점 사이의 직선 거리를 계산하되 DEM이 보여주는 지표면의 실질적인 굴곡을 감안하는 정도이지만(예를 들어 spatialEco 패키지의 top.distance() 함수), topoDistance 패키지는 표면 거리를 최소화하는 경로를 설정하고 그 때의 표면 거리를 산출해준다. 그런데 문제는 topdDist() 함수는 오로지 포인트 벡터만 받아 그들 사이의 최소 지형 거리만을 산출해 준다는 것이다. 물론 apply 문을 이용해 계산을 할 수는 있으나 시간이 너무 많이 소요된다. 따라서 여기서는 소방서간 지형 거리를 산출하는 것만 해본다. 직선 거리와 비교해보면 지형 거리의 개념을 보다 명확히 할 수 있다.\n\nlibrary(topoDistance)\nlibrary(raster)\n\ndem_seoul_mask_r &lt;- raster(dem_seoul_mask) # topoDist는 terra 형식은 받지 않고 raster 형식만 받음.\n\nseoul_sobang_coords &lt;- seoul_sobang |&gt; \n  st_coordinates() |&gt; \n  as.matrix()\n\ndem_seoul_mask_r |&gt; \n  topoDist(seoul_sobang_coords) -&gt; sobang_topo_dist\nseoul_sobang |&gt; \n  st_distance() -&gt; sobang_eucl_dist\n\n최소 지형 거리의 경로도 계산하고 그것을 지도화할 수도 있다. 그런데 시간이 너무 많이 걸리기 때문에 소방서 3개만 가지고 계산한다. 결과는 전혀 현실적이지 않다.\n\nseoul_sobang_coords_3 &lt;- seoul_sobang |&gt; \n  filter(\n    Name %in% c(\"강서소방서\", \"관악소방서\", \"송파소방서\")\n  ) |&gt; \n  st_coordinates() |&gt; \n  as.matrix()\n\ndem_seoul_mask_r |&gt; \n  topoDist(seoul_sobang_coords_3, paths = TRUE) -&gt; sobang_topo_dist_3\n\ntopoPathMap(dem_seoul_mask_r, seoul_sobang_coords_3, \n            topoPaths = sobang_topo_dist_3, type = \"hillshade\",\n            pathWidth = 4, cex = 2, bg = \"blue\")",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>19</span>  <span class='chapter-title'>근접성 분석</span>"
    ]
  },
  {
    "objectID": "raster_overlay.html",
    "href": "raster_overlay.html",
    "title": "\n20  중첩 분석\n",
    "section": "",
    "text": "20.1 준비\n필수적인 패키지를 설치한다. 래스터 분석을 위한 기본 패키지를 raster를 사용한다.\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(sf)\nlibrary(tmap)\n사례 데이터를 불러온다. 이것은 West Virginia 주의 한 지역에 대한 것이다. Raster-Based Spatial Analysis in R을 참고하였다.\nelev &lt;- rast(\"D:/My R/GIS/래스터분석사례데이터/elevation1.tif\")\nslp &lt;- rast(\"D:/My R/GIS/래스터분석사례데이터/slope1.tif\")\nlc &lt;- rast(\"D:/My R/GIS/래스터분석사례데이터/lc_example.tif\")\nairports &lt;- st_read(\"D:/My R/GIS/래스터분석사례데이터/airports.shp\")\ninterstates &lt;- st_read(\"D:/My R/GIS/래스터분석사례데이터/interstates.shp\")\npnts &lt;- st_read(\"D:/My R/GIS/래스터분석사례데이터/example_points.shp\")\nws &lt;- st_read(\"D:/My R/GIS/래스터분석사례데이터/watersheds.shp\")\nstr &lt;- st_read(\"D:/My R/GIS/래스터분석사례데이터/structures.shp\")",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>중첩 분석</span>"
    ]
  },
  {
    "objectID": "raster_overlay.html#사례-분석",
    "href": "raster_overlay.html#사례-분석",
    "title": "\n20  중첩 분석\n",
    "section": "\n20.2 사례 분석",
    "text": "20.2 사례 분석\n적지 분석(suitability analysis)를 수행하고자 한다. 네 가지 조건이 개입된다.\n\n높은 고도\n낮은 경사도\n공항 근접성\n고속도로 근접성\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(elev) + tm_raster(style= \"cont\", title = \"Elevation(m)\") +\n  tm_shape(airports) + tm_bubbles(col=\"black\") +\n  tm_shape(interstates) + tm_lines() +\n  tm_layout(legend.outside = TRUE)\nmy_map\n\n\n\n\n\n\n\n공항으로부터의 거리를 계산한다.\n\nairports |&gt; \n  rasterize(elev, field = \"OBJECTID\") -&gt; airports.raster\nairports.raster |&gt; \n  distance()/1000 -&gt; airports.dist\nnames(airports.dist) &lt;- \"Distance\"\n\n주간 고속도로로부터의 거리를 계산한다.\n\ninterstates |&gt; \n  rasterize(elev, field = \"OBJECTID\") -&gt; interstates.raster\ninterstates.raster |&gt; \n  distance()/1000 -&gt; interstates.dist\nnames(interstates.dist) &lt;- \"Distance\"\n\n\n20.2.1 이항 모델: 보수적 모델\n이항 모델의 규준은 다음과 같이 주어진다.\n\n고도: 500m 초과\n경사도: 15도 미만\n공항 근접성: 공항으로부터 7km 이내\n고속도로 근접성: 주간 고속도로로부터 5km 이내\n\n네 조건에 대한 재분류를 실행한다.\n\nelev &gt; 500 -&gt; elev_binary\nnames(elev_binary) &lt;- \"Reclassified\"\nele_b &lt;- tm_shape(elev_binary) + tm_raster(style=\"cat\", title = \"&gt; 500m\") +\n  tm_legend(legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(main.title=\"Elevation\")\n\nslp &lt; 15 -&gt; slp_binary\nnames(slp_binary) &lt;- \"Reclassified\"\nslp_b &lt;- tm_shape(slp_binary) + tm_raster(style=\"cat\", title = \"&lt; 15\") +\n  tm_legend(legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(main.title=\"Slope\")\n\nairports.dist &lt; 7 -&gt; air_binary\nnames(air_binary) &lt;- \"Reclassified\"\nairport_b &lt;- tm_shape(air_binary) + tm_raster(style=\"cat\", title = \"&lt; 7km\") +\n  tm_legend(legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(main.title=\"Airports\")\n\ninterstates.dist &lt; 5 -&gt; inter_binary\nnames(inter_binary) &lt;- \"Reclassified\"\ninterstate_b &lt;- tm_shape(inter_binary) + tm_raster(style=\"cat\", title = \"&lt; 5km\") +\n  tm_legend(legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(main.title=\"Interstates\")\n\n재분류 지도를 제작한다.\n\nmy_map &lt;- tmap_arrange(ele_b, slp_b, airport_b, interstate_b)\nmy_map\n\n\n\n\n\n\n\n최종 지도를 제작한다.\n\nc_model &lt;- elev_binary*slp_binary*air_binary*inter_binary\nmy_map &lt;- tm_shape(c_model) + tm_raster(style = \"cat\", labels = c(\"Not Suitable\", \"Suitable\"), title = \"Decision\") +\n  tm_layout(legend.outside = TRUE)\nmy_map\n\n\n\n\n\n\n\n\n20.2.2 점수-가중치 모델(진보적 모델)\n점수-가중치 모델의 규준은 다음과 같다.\n\n고도: 높을수록 더 선호\n경사도: 낮을수록 더 선호\n공항 근접성: 가까울수록 더 선호\n고속도로 근접성: 가까울수록 더 선호\n\n네 조건에 대한 재분류를 실행한다. global() 함수를 통해 최대값과 최소값을 구한 뒤, 범위 표준화를 적용하여 분류 순위부여(classification ranking)을 수행한다.\n\nelev |&gt; \n  global(fun = \"min\", na.rm = TRUE) |&gt; \n  as.numeric() -&gt; elev_min\nelev |&gt; \n  global(fun = \"max\", na.rm = TRUE) |&gt; \n  as.numeric() -&gt; elev_max\nelev_score &lt;- ((elev - elev_min)/(elev_max - elev_min))\nnames(elev_score) &lt;- \"Reclassified\"\nele_s &lt;- tm_shape(elev_score) + tm_raster(style=\"cont\") +\n  tm_legend(legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(main.title=\"Elevation\")\n\nslp |&gt; \n  global(fun = \"min\", na.rm = TRUE) |&gt; \n  as.numeric() -&gt; slp_min\nslp |&gt; \n  global(fun = \"max\", na.rm = TRUE) |&gt; \n  as.numeric() -&gt; slp_max\nslp_score &lt;- 1 - ((slp - slp_min)/(slp_max - slp_min))\nnames(slp_score) &lt;- \"Reclassified\"\nslp_s &lt;- tm_shape(slp_score) + tm_raster(style=\"cont\") +\n  tm_legend(legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(main.title=\"Slope\")\n\nairports.dist |&gt; \n  global(fun = \"min\", na.rm = TRUE) |&gt; \n  as.numeric() -&gt; air_min\nairports.dist |&gt; \n  global(fun = \"max\", na.rm = TRUE) |&gt; \n  as.numeric() -&gt; air_max\nair_score &lt;- 1 - ((airports.dist - air_min)/(air_max - air_min))\nnames(air_score) &lt;- \"Reclassified\"\nairport_s &lt;- tm_shape(air_score) + tm_raster(style=\"cont\") +\n  tm_legend(legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(main.title=\"Airports\")\n\ninterstates.dist |&gt; \n  global(fun = \"min\", na.rm = TRUE) |&gt; \n  as.numeric() -&gt; inter_min\ninterstates.dist |&gt; \n  global(fun = \"max\", na.rm = TRUE) |&gt; \n  as.numeric() -&gt; inter_max\ninter_score &lt;- 1- (interstates.dist - inter_min)/(inter_max - inter_min)\nnames(inter_score) &lt;- \"Reclassified\"\ninterstate_s &lt;- tm_shape(inter_score) + tm_raster(style=\"cont\") +\n  tm_legend(legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(main.title=\"Interstates\")\n\n지도를 제작한다.\n\nmy_map &lt;- tmap_arrange(ele_s, slp_s, airport_s, interstate_s)\nmy_map\n\n\n\n\n\n\n\n최종 지도를 제작한다.\n\nwo_model &lt;- (elev_score*.1)+(slp_score*.4)+(air_score*.2)+(inter_score*.3) \nmy_map &lt;- tm_shape(wo_model) + tm_raster(style=\"cont\", title = \"Weighted Scores\") +\n  tm_layout(legend.outside = TRUE)\nmy_map",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>20</span>  <span class='chapter-title'>중첩 분석</span>"
    ]
  },
  {
    "objectID": "raster_intro.html",
    "href": "raster_intro.html",
    "title": "\n14  개요\n",
    "section": "",
    "text": "14.1 래스터 기초",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>개요</span>"
    ]
  },
  {
    "objectID": "raster_intro.html#래스터-기초",
    "href": "raster_intro.html#래스터-기초",
    "title": "\n14  개요\n",
    "section": "",
    "text": "14.1.1 래스터 좌표계\n래스터 좌표계는 기본적으로 그리드 좌표계(grid coordinate system)을 사용하지만, 빠른 검색을 위해 셀위치 좌표계(cell position coordinate system)도 함께 사용한다.\n그리드 좌표계의 원점(0, 0)은 CRS에 의거해 주어지는 것으로 서남쪽 어딘가(보통 해당 그리드 내부에 있지 않음) 존재한다. 그러므로 동쪽과 북쪽으로 갈수록 좌표값이 증가한다. 해당 그리드의 최서남단 꼭지점에 동거와 북거가 가장 작은 지점이 존재하고, 이것을 해당 래스터의 그리드 원점이라고 부른다. 개별 래스터 데이터는 그리드 영역(extent) 정보를 가지고 있는데, 동거의 최소값과 최대값, 북거의 최소값과 최대값이 주어진다. 이 정보와 셀 크기(그리드 셀의 한 변의 길이)를 이용해 래스터 내부의 위치(주로, 개별 그리드 셀의 네 꼭지점 좌표와 셀 중심점 좌표)에 대한 좌표값을 알 수 있다.\n\n셀위치 좌표계의 좌표값은 지점에 대한 것이 아니라 그리드 셀 전체의 인덱스로, 해당 그리드 내에서만 통용된다. 최서북단 그리드가 원점 구실을 하고, 그 그리드 셀의 좌표값은 (0, 0)이다. 그것으로부터 동쪽으로 갈수록 셀 좌표값이 1씩 증가하고, 남쪽으로 갈수록 셀 좌표값이 1씩 증가한다. 개별 그리드 셀의 좌표값은 y 축을 먼저 읽고 다음에 x 축을 읽는 방식을 취한다. 그러므로 원점 셀 바로 아래에 있는 셀의 좌표값은 (1, 0)이다.\n\n여기에 덧붙여 셀 일련번호(cell number)라는 것이 있다. 이것은 셀마다 인덱스 번호를 부여한 것인데, 좌상끝에 위치한 셀에 1을 부여하고, 행별로 일련번호를 붙여나가, 우하끝에 위치한 셀에 마지막 번호를 부여한 것이다.",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>개요</span>"
    ]
  },
  {
    "objectID": "raster_intro.html#래스터-레이어의-사례-서울시-dem",
    "href": "raster_intro.html#래스터-레이어의-사례-서울시-dem",
    "title": "\n14  개요\n",
    "section": "\n14.2 래스터 레이어의 사례: 서울시 DEM",
    "text": "14.2 래스터 레이어의 사례: 서울시 DEM\n\n14.2.1 데이터 불러오기\n필수적인 패키지를 설치한다. 래스터 분석을 위한 기본 패키지를 terra를 사용한다.\n\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(sf)\nlibrary(tmap)\n\n서울에 대한 SRTM 기반 DEM 데이터를 불러온다.\n\ndem_seoul &lt;- rast(\"D:/My R/World Data Manupulation/USGS EarthExplorer/srtm_seoul.tif\")\ndem_seoul_mask &lt;- rast(\"D:/My R/World Data Manupulation/USGS EarthExplorer/srtm_seoul_mask.tif\")\n\n서울의 행정구역 바운더리 파일을 불러온다.\n\nseoul &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\")\nseoul_gu &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\")\nseoul_dong &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\")\n\n\n14.2.2 기본적인 지오메트리 확인\n기본적인 지오메트리 파라미터값을 알아본다.\n\ndem_seoul\n\nclass       : SpatRaster \ndimensions  : 1169, 1428, 1  (nrow, ncol, nlyr)\nresolution  : 25.92782, 25.92782  (x, y)\nextent      : 935046.3, 972071.2, 1936672, 1966982  (xmin, xmax, ymin, ymax)\ncoord. ref. : KGD2002 / Unified CS (EPSG:5179) \nsource      : srtm_seoul.tif \nname        : n37_e126_1arc_v3 \nmin value   :     9.129879e-04 \nmax value   :     8.118753e+02 \n\n\n개별 파라미터 값을 다음과 같이 알아본다.\n\next(dem_seoul) # 범역\n\nSpatExtent : 935046.294557821, 972071.227871716, 1936672.39531736, 1966982.02209884 (xmin, xmax, ymin, ymax)\n\n\n\nres(dem_seoul) # 셀 크기\n\n[1] 25.92782 25.92782\n\n\n\ndim(dem_seoul) # 가로 세로 그리드 셀 수\n\n[1] 1169 1428    1\n\n\n\nncell(dem_seoul) # 총 그리드 셀 수\n\n[1] 1669332\n\n\n\npersp(dem_seoul) # 3D 시각화\n\n\n\n\n\n\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(dem_seoul, raster.downsample = FALSE) + \n  tm_raster(style = \"cont\", palette = c(\"forestgreen\",\"yellow\",\"tan\",\"brown\"), title = \"Elev.(m)\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.06), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.07, 0.04, 0.06, 0.04), \n            title = \"DEM for Seoul\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n14.2.3 래스터 좌표계의 왕래\n셀 일련번호와 셀위치 좌표계를 왕래할 수 있다. 우선 셀 일련번호를 알고 있는 경우, 그것의 셀위치 좌표의 행값을 알아내려면 다음과 같이 하면 된다. 10,000번째 셀의 셀위치 좌표계의 행값이 8, 열값이 4임을 알 수 있다. 그러므로 행위치 좌표값은 (8, 4)이다.\n\nrowFromCell(dem_seoul, 10000)\n\n[1] 8\n\n\n\ncolFromCell(dem_seoul, 10000)\n\n[1] 4\n\n\n거꾸로 셀위치 좌표값을 알고 있는 경우, 그것의 셀 일련번호를 알아내려면 다음과 같이 하면 된다.\n\ncellFromRowCol(dem_seoul, 8, 4)\n\n[1] 10000\n\n\n또한 셀 일련번호와 그리드 좌표계를 왕래할 수 있다. 우선 셀 일련번호를 알고 있는 경우, 그것의 셀위치 좌표의 행값을 알아내려면 다음과 같이 하면 된다.\n\nxyFromCell(dem_seoul, 10000)\n\n          x       y\n[1,] 935137 1966788\n\n\n거꾸로 그리드 좌표값을 알고 있는 경우, 그것의 셀 일련번호를 알아내려면 다음과 같이 하면 된다.\n\ncellFromXY(dem_seoul, cbind(935137, 1966788))\n\n[1] 10000\n\n\n또한 셀위치 좌표계와 그리드 좌표계를 왕래할 수 있다. 우선 그리드의 x-좌표를 알고 있는 경우, 그것의 셀위치 좌표의 열값을 알아내려면 다음과 같이 하면 된다.\n\ncolFromX(dem_seoul, 935137)\n\n[1] 4\n\n\n그리드의 y-좌표를 알고 있는 경우, 그것의 셀위치 좌표의 행값을 알아내려면 다음과 같이 하면 된다.\n\nrowFromY(dem_seoul, 1966788)\n\n[1] 8\n\n\n\n14.2.4 셀 값의 확인\nextract() 함수를 이용하면 셀 값을 얻을 수 있다. 가장 단순한 방법은 셀 일련번호를 아는 경우이다.\n\ndem_seoul |&gt; \n  extract(10000)\n\n  n37_e126_1arc_v3\n1         36.23445\n\n\n다음으로 그리드 좌표를 아는 경우는 다음과 같이 구할 수 있다\n\ndem_seoul |&gt;  \n  extract(cbind(935137, 1966788))\n\n  n37_e126_1arc_v3\n1         36.23445\n\n\n셀위치 좌표를 아는 경우 막바로 구할 수 없고, 먼저 셀 일련번호로 전환한 후 구할 수 있다.\n\ncell_num &lt;- cellFromRowCol(dem_seoul, 8, 4)\ndem_seoul |&gt; \n  extract(cell_num)\n\n  n37_e126_1arc_v3\n1         36.23445\n\n\n\n14.2.5 요약 통계량\n최소값과 최대값은 다음과 같이 구할 수 있다.\n\nminmax(dem_seoul)\n\n    n37_e126_1arc_v3\nmin     9.129879e-04\nmax     8.118753e+02\n\n\n다음과 같은 global() 함수를 이용할 수도 있다.\n\nglobal(dem_seoul, fun = \"max\", na.rm = TRUE)\n\n                      max\nn37_e126_1arc_v3 811.8753\n\nglobal(dem_seoul, fun = \"min\", na.rm = TRUE)\n\n                          min\nn37_e126_1arc_v3 0.0009129879\n\n\n다음과 같이 하면 최소값과 해당 셀의 일련번호를 구할 수 있다.\n\nwhere.min(dem_seoul)\n\n     layer    cell        value\n[1,]     1 1595536 0.0009129879\n\n\n다음과 같이 하면 최대값과 해당 셀의 일련번호를 구할 수 있다.\n\nwhere.max(dem_seoul)\n\n     layer   cell    value\n[1,]     1 259198 811.8753\n\n\n이 정보를 바탕으로 최대값을 보이는 지점의 좌표값을 구할 수 있다.\n\ndem_max_xy &lt;- xyFromCell(dem_seoul, where.max(dem_seoul)[,2])\ndem_max_xy\n\n            x       y\n[1,] 953960.6 1962276\n\n\n벡터 포인트 객체로 만들 수 있다.\n\ndem_max_xy |&gt; \n  st_point() |&gt; \n  st_sfc(crs = st_crs(seoul)) |&gt; \n  st_sf() -&gt; dem_max_sf\n\n혹은 다른 방식으로 만들 수도 있다.\n\ndem_max_xy |&gt; \n  as_tibble() |&gt; \n  st_as_sf(coords = c(\"x\", \"y\"), crs = st_crs(seoul)) -&gt; dem_max_sf",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>14</span>  <span class='chapter-title'>개요</span>"
    ]
  },
  {
    "objectID": "vector_reclassification.html#속성에-기반한-재분류",
    "href": "vector_reclassification.html#속성에-기반한-재분류",
    "title": "\n12  재분류\n",
    "section": "\n12.2 속성에 기반한 재분류",
    "text": "12.2 속성에 기반한 재분류\n\n12.2.1 재코드화(recoding)\n재코드화는 그룹화 속성에 의거해 피처를 그룹화함으로써 보다 단순화된 벡터 레이러를 생성하는 오퍼레이션이다. 재코드화의 가장 완벽한 예시는 보다 하위의 분류체계를 보다 상위의 분류체계로 전환하는 것이다.\n서울시 토지피복도를 제작한다. 먼저 컬러 스케을 지정한다.\n\nlandcover_L2_color &lt;- c(\"주거지역\" = \"#fee6c2\",\n                     \"공업지역\" = \"#c08484\",\n                     \"상업지역\" = \"#ed83b8\", \n                     \"문화·체육·휴양지\" = \"#f67189\",\n                     \"교통지역\" = \"#f7422a\",\n                     \"공공시설지역\" = \"#f6b212\",\n                     \"논\" = \"#ffffbf\", \n                     \"밭\" = \"#f7f966\",\n                     \"시설재배지\" = \"#dfdb73\",\n                     \"과수원\" = \"#b8b12c\",\n                     \"기타재배지\" = \"#b89112\",\n                     \"활엽수림\" = \"#34a02c\",\n                     \"침엽수림\" = \"#0a4f40\",\n                     \"혼효림\" = \"#336633\",\n                     \"자연초지\" = \"#a1d594\",\n                     \"인공초지\" = \"#607e33\",\n                     \"내륙습지\" = \"#b4a7d0\",\n                     \"연안습지\" = \"#997499\",\n                     \"자연나지\" = \"#c1dbec\",\n                     \"인공나지\" = \"#9ff2ff\",\n                     \"내륙수\" = \"#3ea8ff\", \n                     \"해양수\" = \"#1739ff\"\n                      )\nseoul_landcover_M &lt;- seoul_landcover_M |&gt; \n  mutate(\n    L2_NAME = fct(L2_NAME, levels = c(\"주거지역\", \"공업지역\", \"상업지역\", \"문화·체육·휴양지\",\n                                      \"교통지역\", \"공공시설지역\", \"논\", \"밭\", \"시설재배지\",\n                                      \"과수원\", \"기타재배지\", \"활엽수림\", \"침엽수림\", \"혼효림\",\n                                      \"자연초지\", \"인공초지\", \"내륙습지\", \"연안습지\", \"자연나지\", \n                                      \"인공나지\", \"내륙수\", \"해양수\"))\n  )\nlandcover_L1_color &lt;- c(\"시가화·건조지역\" = \"#FF0000\",\n                        \"농업지역\" = \"#EEE907\",\n                        \"산림지역\" = \"#2A4B2D\",\n                        \"초지\" = \"#399926\",\n                        \"습지(수변식생)\" = \"#7C227E\",\n                        \"나지\" = \"#59CECA\",\n                        \"수역\" = \"#0602FA\"\n                        )\nseoul_landcover_L &lt;- seoul_landcover_L |&gt; \n  mutate(\n    L1_NAME = fct(L1_NAME, levels = c(\"시가화·건조지역\", \"농업지역\", \"산림지역\", \"초지\", \n                                      \"습지(수변식생)\", \"나지\", \"수역\"))\n  )\n\n중분류 지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_landcover_M) + \n  tm_polygons(col = \"L2_NAME\", style = \"cat\", palette = landcover_L2_color, border.alpha = 0, legend.show = TRUE) +\n  tm_shape(seoul_sido) + tm_borders(lwd = 1) +\n  tm_legend(legend.position = c(0.89, 0.03)) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.14), \n            title = \"Landcover Classification: L2\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) +   tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n대분류 지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_landcover_L) + \n  tm_polygons(col = \"L1_NAME\", style = \"cat\", palette = landcover_L1_color, border.alpha = 0, legend.show = TRUE) +\n  tm_shape(seoul_sido) + tm_borders(lwd = 1) +\n  tm_legend(legend.position = c(0.89, 0.03)) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.14), \n            title = \"Landcover Classification: L1\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) +   tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "벡터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>12</span>  <span class='chapter-title'>재분류</span>"
    ]
  },
  {
    "objectID": "raster_reclassification.html",
    "href": "raster_reclassification.html",
    "title": "\n18  재분류\n",
    "section": "",
    "text": "18.1 준비\n필수적인 패키지를 설치한다. 래스터 분석을 위한 기본 패키지로 terra를 사용한다.\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(sf)\nlibrary(tmap)\n서울에 대한 SRTM 기반 DEM 데이터를 불러온다.\ndem_seoul &lt;- rast(\"D:/My R/World Data Manupulation/USGS EarthExplorer/srtm_seoul.tif\")\ndem_seoul_mask &lt;- rast(\"D:/My R/World Data Manupulation/USGS EarthExplorer/srtm_seoul_mask.tif\")\n서울의 행정구역 바운더리 파일을 불러온다.\nseoul &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\")\nseoul_gu &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\")\nseoul_dong &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\")",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>재분류</span>"
    ]
  },
  {
    "objectID": "raster_reclassification.html#정의와-구분",
    "href": "raster_reclassification.html#정의와-구분",
    "title": "\n18  재분류\n",
    "section": "\n18.2 정의와 구분",
    "text": "18.2 정의와 구분",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>재분류</span>"
    ]
  },
  {
    "objectID": "raster_reclassification.html#로컬-재분류",
    "href": "raster_reclassification.html#로컬-재분류",
    "title": "\n18  재분류\n",
    "section": "\n18.3 로컬 재분류",
    "text": "18.3 로컬 재분류\n\n18.3.1 이항 매스킹\n이항 매스킹을 통해 새로운 래스터를 생성한다.\n\ndem_seoul &gt;= 250 -&gt; dem_seoul_250\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(dem_seoul_250, raster.downsample = FALSE) + tm_raster(style = \"cat\", labels = c(\"No\", \"Yes\"), title = \"Elev. &gt;= 250\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.07, 0.04, 0.06, 0.04), \n            title = \"Reclassification: Binary Masking\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n18.3.2 분류 순위부여\n분류 순위부여를 통해 새로운 래스터를 생성한다. raster 패키지의 reclassify() 함수가 terra 패키지에서 classify()로 바뀌었다.\n\nrclmat &lt;- matrix(c(-Inf, 100, 1, 100, 200, 3, 200, 300, 5, 300, 400, 7, 400, Inf, 9), ncol = 3, byrow = TRUE)\n\ndem_seoul |&gt; \n  classify(rclmat, include.lowest = TRUE) -&gt; dem_seoul_rec\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(dem_seoul_rec, raster.downsample = FALSE) + tm_raster(style = \"cat\", title = \"Classes\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.07, 0.04, 0.06, 0.04), \n            title = \"Reclassification: Classification Ranking\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>18</span>  <span class='chapter-title'>재분류</span>"
    ]
  },
  {
    "objectID": "part_6.html",
    "href": "part_6.html",
    "title": "GIS 모델링과 고급 GIS 분석",
    "section": "",
    "text": "공간모델링이란 지리공간적 사상과 그것의 작동 및 관련 방식을 특정한 프레임워크 속에서 모사함으로써, 공간적 문제를 해결하거나 지리적 연구 과제를 수행하는 것을 의미한다. 다음과 같은 두 가지 종류가 있을 수 있다.\n\n주제에 따른 분류: 자연환경적 모델, 인문사회적 모델, 종합 모델\n적용 기법에 따른 분류: 개념적 모델(시스템 다이어그램), 수리통계적 모델, 시뮬레이션 모델(CA, ABM 등) 등\n\nGIS 모델링은 공간모델링을 GIS의 맥락 속에서 행하는 것을 의미한다. 즉, GIS 모델링은 GIS-기반 공간모델링을 의미한다. 좀더 구체적으로 정의하면, GIS 모델링이란 특정한 목적(공간적 문제 해결, 지리적 연구 과제 수행 등)을 위해 GIS 오퍼레이션을 체계적으로 조합ㆍ연계시키는 일련의 과정을 의미한다.\n고급 GIS 분석에서 고급(advanced)은 두 가지를 의미한다. 보다 복잡한 GIS 오퍼레이션의 적용하거나 특수 목적형 GIS 오퍼레이션의 적용한 것을 의미한다. 종류에 다음과 같은 것이 있을 수 있다.\n\n지형 분석(terrain analysis)\n네트워크 분석(network analysis)\n수문 분석(hydrologic analysis)\n공간통계 분석(spatial statistical analysis)\n3D 혹은 4D 분석(3-dimensional or 4-dimensional analysis)",
    "crumbs": [
      "GIS 모델링과 고급 GIS 분석"
    ]
  },
  {
    "objectID": "sm_intro.html",
    "href": "sm_intro.html",
    "title": "21  GIS 모델링",
    "section": "",
    "text": "21.1 개요",
    "crumbs": [
      "GIS 모델링과 고급 GIS 분석",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>GIS 모델링</span>"
    ]
  },
  {
    "objectID": "sm_intro.html#적합성-모델링",
    "href": "sm_intro.html#적합성-모델링",
    "title": "21  GIS 모델링",
    "section": "21.2 적합성 모델링",
    "text": "21.2 적합성 모델링\n\n21.2.1 가중치 부여와 결합\n\n\n21.2.2 AHP 방법",
    "crumbs": [
      "GIS 모델링과 고급 GIS 분석",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>GIS 모델링</span>"
    ]
  },
  {
    "objectID": "sm_intro.html#개요",
    "href": "sm_intro.html#개요",
    "title": "21  GIS 모델링",
    "section": "",
    "text": "21.1.1 GIS-기반 공간모델링",
    "crumbs": [
      "GIS 모델링과 고급 GIS 분석",
      "<span class='chapter-number'>21</span>  <span class='chapter-title'>GIS 모델링</span>"
    ]
  },
  {
    "objectID": "sm_terrain.html",
    "href": "sm_terrain.html",
    "title": "\n22  지형 분석\n",
    "section": "",
    "text": "22.1 수치지형모델",
    "crumbs": [
      "GIS 모델링과 고급 GIS 분석",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>지형 분석</span>"
    ]
  },
  {
    "objectID": "sm_terrain.html#수치지형모델",
    "href": "sm_terrain.html#수치지형모델",
    "title": "\n22  지형 분석\n",
    "section": "",
    "text": "22.1.1 종류\n\n22.1.2 DEM 데이터",
    "crumbs": [
      "GIS 모델링과 고급 GIS 분석",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>지형 분석</span>"
    ]
  },
  {
    "objectID": "sm_terrain.html#dem-분석",
    "href": "sm_terrain.html#dem-분석",
    "title": "\n22  지형 분석\n",
    "section": "\n22.2 DEM 분석",
    "text": "22.2 DEM 분석\n\n22.2.1 준비\n필수적인 패키지를 설치한다. 래스터 분석을 위한 기본 패키지를 terra를 사용한다.\n\nlibrary(tidyverse)\nlibrary(terra)\nlibrary(sf)\nlibrary(tmap)\n\n서울에 대한 SRTM 기반 DEM 데이터를 불러온다.\n\ndem_seoul &lt;- rast(\"D:/My R/World Data Manupulation/USGS EarthExplorer/srtm_seoul.tif\")\ndem_seoul_mask &lt;- rast(\"D:/My R/World Data Manupulation/USGS EarthExplorer/srtm_seoul_mask.tif\")\n\n서울의 행정구역 바운더리 파일을 불러온다.\n\nseoul &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\")\nseoul_gu &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\")\nseoul_dong &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\")\n\n\n22.2.2 지형 요소의 추출\n\n22.2.2.1 경사\nterrain() 함수를 이용하여 경사(slope)를 계산한다.\n\nseoul_slope &lt;- dem_seoul_mask |&gt; \n  terrain(v = \"slope\", neighbors = 8, unit = \"degrees\")\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_slope, raster.downsample = FALSE) + \n  tm_raster(style = \"fixed\", breaks = c(0, 5, 10, 15, 20, 25, 30, 35, Inf), palette = \"-RdYlGn\", title = \"Slope\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Slope\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n22.2.2.2 향\nterrain() 함수를 이용하여 향(aspect)을 계산한다.\n\nseoul_aspect &lt;- dem_seoul_mask |&gt; \n  terrain(v = \"aspect\", neighbors = 8, unit = \"degrees\")\n\n지도를 제작한다.\n\naspect_col &lt;- c(\"#84D600\", \"#00AB44\", \"#0068C0\", \"#6C00A3\", \"#CA009C\", \"#FF5568\", \"#FFAB47\", \"#F4FA00\", \"#84D600\")\n\nmy_map &lt;- tm_shape(seoul_aspect) + \n  tm_raster(style = \"fixed\", \n            breaks = c(0, 22.5, 67.5, 112.5, 157.5, 202.5, 247.5, 292.5, 337.5, 360), \n            labels = c(\"N\", \"NE\", \"E\", \"SE\", \"S\", \"SW\", \"W\", \"NW\", \"N\"), \n            palette = aspect_col, title = \"Aspect\", legend.is.portrait = FALSE) +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Aspect\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n22.2.2.3 TRI(Terrain Ruggedness Index)\n\nseoul_TRI &lt;- dem_seoul_mask |&gt; \n  terrain(v = \"TRI\", neighbors = 8, unit = \"degrees\")\n\n\nmy_map &lt;- tm_shape(seoul_TRI, raster.downsample = FALSE) + tm_raster(style = \"cont\", palette = \"Purples\", title = \"TRI\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: TRI\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n22.2.2.4 TPI(Topographic Position Index)\n\nseoul_TPI &lt;- dem_seoul_mask |&gt; \n  terrain(v = \"TRI\", neighbors = 8, unit = \"degrees\")\n\n\nmy_map &lt;- tm_shape(seoul_TPI, raster.downsample = FALSE) + tm_raster(style = \"cont\", palette = \"Purples\", title = \"TPI\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: TPI\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n22.2.2.5 Roughness\n\nseoul_roughness &lt;- dem_seoul_mask |&gt; \n  terrain(v = \"roughness\", neighbors = 8, unit = \"degrees\")\n\n\nmy_map &lt;- tm_shape(seoul_roughness, raster.downsample = FALSE) + tm_raster(style = \"cont\", palette = \"Purples\", title = \"Roughness\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Roughness\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n22.2.2.6 Flow Direction\n\nseoul_flowdir &lt;- dem_seoul_mask |&gt; \n  terrain(v = \"flowdir\", neighbors = 8, unit = \"degrees\")\n\n\nmy_map &lt;- tm_shape(seoul_flowdir, raster.downsample = FALSE) + tm_raster(style = \"cont\", palette = \"Purples\", title = \"Flow Direction\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Flow Direction\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n22.2.2.7 곡률: 종곡률(profile curvature)\n곡률은 spatialEco 패키지를 활용하여 계산한다.\n\nlibrary(spatialEco)\nseoul_curv_profile &lt;- curvature(dem_seoul_mask, type = \"profile\")\nseoul_curv_profile &lt;- dem_seoul_mask |&gt; \n  curvature(type = \"profile\")\n\n지도를 제작한다. 연속형은 별로 좋지 않을 것 같음.\n\nmy_map &lt;- tm_shape(seoul_curv_profile, raster.downsample = FALSE) + tm_raster(style = \"quantile\", palette = \"BrBG\", title = \"Curvature\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Profile Curvature\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n22.2.2.8 곡률: 횡곡률(plan curvature)\n\nseoul_curv_plan &lt;- dem_seoul_mask |&gt; \n  curvature(type = \"planform\")\n\n지도를 제작한다. 연속형은 별로 좋지 않을 것으로 보인다.\n\nmy_map &lt;- tm_shape(seoul_curv_plan, raster.downsample = FALSE) + tm_raster(style = \"quantile\", palette = \"BrBG\", title = \"Curvature\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Plan Curvature\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n22.2.3 시각화\n\n22.2.3.1 힐셰이딩(hillshading)\nslope와 aspect를 라디안 단위로 생성하고, shade() 함수에 두 개를 투입하면 힐셰이드 래스터 래이어를 얻을 수 있다.\n\nseoul_slope_radian &lt;- dem_seoul_mask |&gt; \n  terrain(v = \"slope\", neighbors = 8, unit = \"radians\")\nseoul_aspect_radian &lt;- dem_seoul_mask |&gt; \n  terrain(v = \"aspect\", neighbors = 8, unit = \"radians\")\nseoul_hillshade &lt;- shade(\n  seoul_slope_radian, \n  seoul_aspect_radian, angle = 45, direction = 45, normalize = TRUE\n  )\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_hillshade, raster.downsample = FALSE) + tm_raster(style = \"cont\", palette = \"-Greys\", title = \"\", legend.show = FALSE) +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Hillshading\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n22.2.3.2 단면도 생성(transverse profiling)\n\n# 두 지점을 연결하는 라인 sf 객체를 만든다.\nline_sf &lt;- tibble(x = c(126.961091, 126.992310), y = c(37.442904, 37.660032)) |&gt; \n  as.matrix() |&gt; # st_linestring()은 매트릭스만 받음\n  st_linestring() |&gt; \n  st_sfc(crs = 4326) |&gt; \n  st_sf(geometry = _) |&gt; # _ 표시는 직전에 만들어진 것을 인풋으로 받는다는 의미\n  st_transform(crs = 5179)\n\n# 라인 상에 적절한 간격의 포인트를 생성한다.\npoints_sf &lt;- line_sf |&gt; \n  st_line_sample(density = 0.1) |&gt; # '단위 길이 당 포인트의 수'를 의미, 10m당 하나씩을 택한다는 의미.\n  st_cast(\"POINT\") |&gt; \n  st_sf() \n\n# 래스터로부터 각 포인트에 해당하는 값을 추출한다.\nelev_profile &lt;- dem_seoul_mask |&gt; \n  extract(points_sf) |&gt; \n  mutate(\n    distance = ID * 10 / 1000, # 10m 당 하나이므로 10을 곱해 거리(m)로 만들고, 1,000으로 나누어 km 단위\n    elevation = n37_e126_1arc_v3,\n    .keep = \"unused\"\n  )\n\n단면 그래프를 제작한다.\n\n# library(units)\nmy_graph &lt;- ggplot(data = elev_profile) +\n  geom_line(aes(x = distance, y = elevation)) +\n  labs(x = \"Distance(km)\", y = \"Elevation(m)\") + \n  theme(aspect.ratio = 1/4)\nmy_graph\n\n\n\n\n\n\n\n두 지점을 연결한 선이 나타나는 레퍼런스 지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_hillshade, raster.downsample = FALSE) + tm_raster(style = \"cont\", palette = \"-Greys\", title = \"\", legend.show = FALSE) +\n  tm_shape(line_sf) + tm_lines(col = \"red\", lwd = 2) +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Transverse Profiling\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n22.2.3.3 컨투어링(contouring)\n\nseoul_contour &lt;- dem_seoul_mask |&gt; \n  as.contour() |&gt; \n  st_as_sf()\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(dem_seoul_mask, raster.downsample = FALSE) + tm_raster(style = \"fixed\", breaks = c(-Inf, 50, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, Inf), palette = \"Greys\", legend.show = FALSE) +\n  tm_shape(subset(seoul_contour, level %in% c(50, 100, 150, 200, 250, 300, 350, 400, 450, 500, 550, 600, 650, 700))) + \n  tm_iso(text = \"level\", color = \"black\", lwd = 1, size = 1, alpha = 0.7) +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Contouring\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n22.2.4 가시성(visibility) 분석\n\n22.2.4.1 가시권(viewshed) 분석\n우선 내 연구실의 경위도 좌표를 평면직각좌표로 전환한다.\n\npoints_sf &lt;- tibble(lon = 126.955184, lat = 37.460422) |&gt; \n  st_as_sf(coords = c(\"lon\", \"lat\"), crs = 4326) |&gt; \n  st_transform(crs = 5179) \nst_coordinates(points_sf)\n\n            X       Y\n[1,] 951818.1 1940275\n\n\nterra 패키지의 viewshed() 함수를 활용하여 가시권을 계산한다.\n\nseoul_viewshed &lt;- dem_seoul_mask |&gt; \n  viewshed(loc = c(951818.1, 1940275), \n           observer = 15, \n           output = \"yes/no\"\n  )\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_hillshade, raster.downsample = FALSE) + tm_raster(style = \"cont\", palette = \"-Greys\", title = \"\", legend.show = FALSE) +\n  tm_shape(seoul_viewshed, raster.downsample = FALSE) + tm_raster(style = \"cat\", title = \"Viewshed\", alpha = 0.5) +\n  tm_shape(points_sf) + tm_symbols(col = \"black\") +\n  tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Viewshed\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n22.2.4.2 가시선(line-of-sight) 분석\n10동 옥상에서 개화산 정상을 바라봤을 때의 가시선 분석을 수행한다.\n우선, 옥상과 개화산 정상으로 이루어진 포인트 피처 레이어를 만든다.\n\npoints_sf_2 &lt;- tibble(X = c(126.955184, 126.803605), Y = c(37.460422, 37.582374)) |&gt; \n  st_as_sf(coords = c(\"X\", \"Y\"), crs = 4326) |&gt; \n  st_transform(crs = 5179) \n\n다음으로, 옥상과 개화산 정상을 연결한 라인 피처 레이어를 생성한다.\n\nline_sf_1 &lt;- tibble(X = c(126.955184, 126.803605), Y = c(37.460422, 37.582374)) |&gt; \n  as.matrix() |&gt; \n  st_linestring() |&gt; \n  st_sfc(crs = 4326) |&gt; \n  st_sf(geometry = _) |&gt; \n  st_transform(crs = 5179)\n\n가시선 분석은 가시권 분석이 이루어진 이상 별다른 가치가 없다. 그러나 특별한 라인 상에서 가시성이 어떻게 나타나는지를 살펴보고 싶을 수는 있다. 가시선을 생성하기 위한 시작은 당연히 가시권면에서 라인이 지나가는 부분의 레스터 셀을 선택하는 것일 것이다.\n\nlos_r &lt;- seoul_viewshed |&gt; \n  mask(line_sf_1)\n\n그런데 이것은 결국 래스터이므로 선형 피처를 얻고자 하는 목적에 부합하지 않는다. 최종적으로 원하는 것은 래스터의 대각선 길이로 라인 세그먼트가 분할되어 있고, 그것의 속성으로 TRUE/FALSE 값이 들어가 있는 벡터 라인 레이어이다. st 패키지의 st_segmentize() 함수와 st_split() 함수를 사용한 방법을 생각해 보았지만 모두 실패하였다.\n그래서 stplanr 패키지의 line_segment() 함수를 사용하고자 한다. 이 함수를 사용하여 전체 라인을 적당한 숫자의 라인 세그먼트로 분할한다. 라인의 전체 길이가 대략 20km 정도이고, 셀 크기를 고려할 때 약 700개 정도이면 적절한 것으로 판단하였다. 그리고 나서 terra 패키지의 extract() 함수를 이용하여 라인 세그먼트의 viewshed 값을 가져온다. 일종의 인터폴레이션을 적용하는 것이기 때문에 함수를 지정해야 하고 이 맥락에서는 max 혹은 min이 적절할 것으로 보인다.\n\nlibrary(stplanr)\nline_segments &lt;- line_sf_1 |&gt; \n  line_segment(\n    n_segments = 700\n  )\nlos_line &lt;- seoul_viewshed |&gt; \n  extract(line_segments, fun = \"max\", bind = TRUE) |&gt; \n  st_as_sf() |&gt; \n  mutate(\n    Yes_No = if_else(viewshed == 1, \"TRUE\", \"FALSE\")\n  )\n\n아래의 방법은 chatGPT 선생이 제안한 방법이다. 속도는 조근 더 빠른 것 같고, viewshed의 값을 읽는 방식이 좀 더 직접적인 것으로 보인다. 그러나 결과에 큰 차이는 없다.\n\nextracted &lt;- extract(seoul_viewshed, line_sf_1, cells = TRUE)\nextracted &lt;- extracted[!is.na(extracted[, \"viewshed\"]), ]  # Filter out No (NA) cells\n\n# Step 3: Loop through adjacent points to create line segments with attributes\nsegments &lt;- list()\nfor (i in 1:(nrow(extracted) - 1)) {\n  # Get coordinates for each pair of adjacent cells\n  coords &lt;- xyFromCell(seoul_viewshed, extracted[c(i, i + 1), \"cell\"])\n  # Create a line segment\n  segment &lt;- vect(coords, type=\"line\", crs=crs(seoul_viewshed))\n  # Assign Yes/No attribute (1 for Yes, NA for No) based on the first point in each pair\n  values(segment) &lt;- data.frame(Yes_No = extracted[i, \"viewshed\"])\n  # Append to list\n  segments[[i]] &lt;- segment\n}\n# Step 4: Combine all segments into a single SpatVector\nline_segments &lt;- do.call(rbind, segments)\nlos_line &lt;- st_as_sf(line_segments)\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul_hillshade, raster.downsample = FALSE) + tm_raster(style = \"cont\", palette = \"-Greys\", title = \"\", legend.show = FALSE) +\n  tm_shape(los_line) + tm_lines(col = \"Yes_No\", style = \"cat\", lwd = 3, title.col = \"Seen or Not\") +\n    tm_shape(seoul) + tm_borders(col = \"gray20\", lwd = 1.5) +\n  tm_shape(points_sf_2) + tm_symbols(col = \"gray10\", size = 1) +\n  tm_legend(legend.position = c(0.85, 0.03), legend.bg.color = \"white\", legend.bg.alpha = 0.6) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"DEM Analysis: Line-of-Site\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 4), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "GIS 모델링과 고급 GIS 분석",
      "<span class='chapter-number'>22</span>  <span class='chapter-title'>지형 분석</span>"
    ]
  },
  {
    "objectID": "sm_network.html",
    "href": "sm_network.html",
    "title": "\n23  네트워크 분석\n",
    "section": "",
    "text": "23.1 준비\n필수적인 패키지를 설치한다. 네트워크 분석에서는 특히 sfnetworks 패키지를 기본으로 사용한다.\nlibrary(tidyverse)\nlibrary(sfnetworks)\nlibrary(sf)\nlibrary(tmap)\n서울의 행정구역 경계 파일을 불러온다.\nseoul &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_SIDO_2023_2Q.shp\")\nseoul_gu &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_GU_2023_2Q.shp\")\nseoul_dong &lt;- st_read(\"D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2023_2Q/SEOUL_EMD_2023_2Q.shp\")\n서울의 소방서 위치를 불러온다.\nseoul_sobang &lt;- st_read(\"D:/My R/Vector Data Manipulation Korea/Seoul_Data_Plaza/sobang_station_seoul.shp\", options = \"ENCODING=CP949\")\n서울시 도로망 데이터를 불러온다.\nseoul_sn &lt;- st_read(\"D:/My R/Vector Data Manipulation Korea/Korea_Transport_Database/seoul_link.shp\", options = \"ENCODING=CP949\")\n\noptions:        ENCODING=CP949 \nReading layer `seoul_link' from data source \n  `D:\\My R\\Vector Data Manipulation Korea\\Korea_Transport_Database\\seoul_link.shp' \n  using driver `ESRI Shapefile'\nSimple feature collection with 33664 features and 37 fields\nGeometry type: MULTILINESTRING\nDimension:     XY\nBounding box:  xmin: 935297 ymin: 1936908 xmax: 971990.4 ymax: 1966117\nProjected CRS: KGD2002 / Unified CS\n\nseoul_sn &lt;- seoul_sn |&gt; \n  st_cast(\"LINESTRING\") # 반드시 수행해야 함. 차이가 뭘까? 위는 MULTILINESTRING임.\n서울시 도로망을 sfn 객체로 만든다.\nseoul_sfn &lt;- seoul_sn |&gt; \n  as_sfnetwork(directed = FALSE)",
    "crumbs": [
      "GIS 모델링과 고급 GIS 분석",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>네트워크 분석</span>"
    ]
  },
  {
    "objectID": "sm_network.html#네트워크-거리-매트릭스",
    "href": "sm_network.html#네트워크-거리-매트릭스",
    "title": "\n23  네트워크 분석\n",
    "section": "\n23.2 네트워크 거리 매트릭스",
    "text": "23.2 네트워크 거리 매트릭스\n\n23.2.0.1 유클리드 거리 매트릭스\n\ndist_matrix_eucl &lt;- seoul_sobang |&gt; \n  st_distance()\n\n\n23.2.0.2 네트워크 거리 매트릭스\n\ndist_matrix_network &lt;- seoul_sfn |&gt; \n  st_network_cost(from = seoul_sobang, to = seoul_sobang, direction = \"all\")",
    "crumbs": [
      "GIS 모델링과 고급 GIS 분석",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>네트워크 분석</span>"
    ]
  },
  {
    "objectID": "sm_network.html#최단-네트워크-경로",
    "href": "sm_network.html#최단-네트워크-경로",
    "title": "\n23  네트워크 분석\n",
    "section": "\n23.3 최단 네트워크 경로",
    "text": "23.3 최단 네트워크 경로\n각 소방서에서 종로소방서로 가는 최단 네트워크 경로를 구한다.\n\njongro_st &lt;- seoul_sobang |&gt; \n  filter(\n    Name == \"종로소방서\"\n  )\nsobang_network_paths_sfn &lt;- seoul_sfn |&gt; \n  st_network_paths(from = jongro_st, to = seoul_sobang)\n\n경로를 라인으로 표현하기 위해서는 sobang_network_paths_sfn 객체를 해부해야 한다. 함수를 작성한다.\n\n# snu_paths_generator &lt;- function(net, paths_sfn, dest.point, id.var){\n#   line.list &lt;- list()\n#   destID &lt;- vector()\n#   n &lt;- nrow(paths_sfn)\n#   for (i in 1:n){\n#     path.index.i &lt;- unlist(slice(paths_sfn, i)$edge_paths)\n#     path.i &lt;- net[path.index.i, ]\n#     line.list[[i]] &lt;- path.i\n#     destID &lt;-  c(destID, rep(dest.point[[id.var]][i], length(path.index.i)))\n#   }\n#   final.line &lt;- do.call(rbind, line.list)\n#   final.line &lt;- cbind(final.line, destID)\n# }\n\nsnu_paths_generator &lt;- function(net, paths_sfn, dest.point, id.var){\n  result &lt;- paths_sfn |&gt; \n    mutate(\n      path.index = map(edge_paths, ~net[unlist(.x), ]),\n      destID = map(1:n(), ~dest.point[[id.var]][.x])\n    )\n  final.line &lt;- result |&gt; \n    unnest(cols = c(path.index, destID)) |&gt;\n    bind_cols() |&gt; st_as_sf()  \n  return(final.line)\n}\n\n이 함수를 활용하여 최단 경로에 대한 라인을 추출한다.\n\nsobang_network_paths_sfn_lines &lt;- seoul_sn |&gt;  \n  snu_paths_generator(sobang_network_paths_sfn, seoul_sobang, \"Name\") #여기서는 seoul_sn 사용\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray70\") +\n  tm_shape(sobang_network_paths_sfn_lines) + tm_lines(lwd = 4)+\n  tm_shape(seoul_sobang) + tm_dots(col = \"Name\", size = 1, legend.show = FALSE) + \n  tm_shape(jongro_st) + tm_dots(col = \"black\", size = 1) + \n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Shortest Network Paths to Jongro Station\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "GIS 모델링과 고급 GIS 분석",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>네트워크 분석</span>"
    ]
  },
  {
    "objectID": "sm_network.html#최적배달경로분석",
    "href": "sm_network.html#최적배달경로분석",
    "title": "\n23  네트워크 분석\n",
    "section": "\n23.4 최적배달경로분석",
    "text": "23.4 최적배달경로분석\n여기서는 TSP 패키지를 사용한다.\n\nlibrary(TSP)\n\ndist_matrix_network &lt;- seoul_sfn |&gt; \n  st_network_cost(from = seoul_sobang, to = seoul_sobang)\nsobang_index &lt;- seoul_sobang |&gt; \n  st_nearest_feature(seoul_sfn) # 가장 가까이에 있는 도로 세그먼트 index\n\n# 소방서간 최단 거리가 아니라 도로 세그먼트 간 최단 거리\ndist_matrix_network &lt;- dist_matrix_network |&gt; \n  as_tibble() |&gt; \n  mutate(row_index = sobang_index) |&gt;     \n  column_to_rownames(var = \"row_index\") |&gt; \n  setNames(sobang_index) |&gt; \n  as.matrix()\n\n# row.names(dist_matrix_network) &lt;- sobang_index\n# colnames(dist_matrix_network) &lt;- sobang_index\n\nTSP_tour &lt;- TSP::solve_TSP(TSP(dist_matrix_network)) # TSP 문제를 해결\nTSP_tour_index &lt;- as.numeric(names(TSP_tour))\n\nround(tour_length(TSP_tour), 0) # 전체 길이를 계산해준다. 128.851m\n\n[1] 129939\n\nfrom_index &lt;- TSP_tour_index\nto_index &lt;- c(TSP_tour_index[2:length(TSP_tour_index)], TSP_tour_index[1])\n\n# TSP_paths &lt;- mapply(st_network_paths, from = from_index, to = to_index, MoreArgs = list(x = seoul_sfn))[\"edge_paths\", ] |&gt; unlist(recursive = FALSE)\n\nTSP_paths &lt;- map2(from_index, to_index, ~st_network_paths(x = seoul_sfn, from = .x, to = .y)$edge_paths) |&gt; \n  unlist(recursive = FALSE)\n\n경로를 라인으로 표현하기 위해서는 TSP_paths 객체를 해부해야 한다. 함수를 작성한다.\n\nsnu_TSP_generator &lt;- function(net, tsp_paths, dest.point, id.var){\n  line.list &lt;- list()\n  destID &lt;- vector()\n  n &lt;- length(tsp_paths)\n  for (i in 1:n){\n    path.index.i &lt;- tsp_paths[[i]]\n    path.i &lt;- net[path.index.i, ]\n    line.list[[i]] &lt;- path.i\n    destID &lt;-  c(destID, rep(dest.point[[id.var]][i], length(path.index.i)))\n  }\n  final.line &lt;- do.call(rbind, line.list)\n  final.line &lt;- cbind(final.line, destID)\n}\n\n이 함수를 활용하여 TSP 경로를 추출한다.\n\nTSP_paths_line &lt;- snu_TSP_generator(seoul_sn, TSP_paths, seoul_sobang, \"Name\")\n\n지도를 작성한다.\n\nmy_map &lt;- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray70\") +\n  tm_shape(TSP_paths_line) + tm_lines(lwd = 4)+\n  tm_shape(seoul_sobang) + tm_dots(col = \"Name\", size = 1, legend.show = FALSE) + \n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Traveling Salesman Problem Path\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "GIS 모델링과 고급 GIS 분석",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>네트워크 분석</span>"
    ]
  },
  {
    "objectID": "sm_network.html#최근접시설물분석",
    "href": "sm_network.html#최근접시설물분석",
    "title": "\n23  네트워크 분석\n",
    "section": "\n23.5 최근접시설물분석",
    "text": "23.5 최근접시설물분석\n\n23.5.0.1 네트워크 할당: line-to-facility\n도로 세그먼트에 최근린 소방서의 ID를 할당하고자 한다.\n\nseoul_sn_cent &lt;- seoul_sn |&gt; \n  st_centroid() # 모든 도로 세그먼트의 센트로이드 생성\n\ndist_cent_sobang &lt;- seoul_sfn |&gt; \n  st_network_cost(from = seoul_sn_cent, to = seoul_sobang) # 모든 도로 세그먼트의 센트로이드로부터 소방서까지의 네트워크 거리 계산\n\n# closest_cent &lt;- seoul_sobang$Name[apply(dist_cent_sobang, 1, function(x) which(x == min(x))[1])] \n\nclosest_cent &lt;- map_int(1:nrow(dist_cent_sobang), ~ {\n  row &lt;- dist_cent_sobang[.x, ]\n  which(row == min(row))[1]\n  }) \n\nseoul_sn$closest &lt;- seoul_sobang$Name[closest_cent]\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"closest\", lwd = 1, legend.col.show = FALSE) +\n  tm_shape(seoul_sobang) + tm_dots(col = \"Name\", shape = 21, border.col = \"black\", size = 1, legend.show = FALSE) + \n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Closest Facilities: Network Allocation\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n\n23.5.0.2 포인트 할당: point-to-facility\n임의의 지점을 선정하고 최근린 소방서를 연결하는 일종의 스파이더 지도(spider map) 혹은 디자이어 라인 지도(desire line map) 지도를 생성한다. 우선 도로 네트워크의 센트로이드 중 임의의 지점 500개를 추출한다.\n\nnetwork_sample &lt;- seoul_sn_cent |&gt; \n  st_sample(500, type = \"random\") |&gt; \n  st_as_sf(crs = 5179) |&gt; \n  st_cast(\"POINT\")\n\n500개 지점에서 최근린 소방서를 확인한다.\n\ndist_sample_sobang &lt;- seoul_sfn |&gt;  \n  st_network_cost(from = network_sample, to = seoul_sobang)\n\n# closest_sample &lt;- seoul_sobang[apply(dist_sample_sobang, 1, function(x) which(x == min(x))[1]), ]\n\nclosest_index &lt;- map_int(1:nrow(dist_sample_sobang), ~ {\n  row &lt;- dist_sample_sobang[.x, ]\n  which(row == min(row))[1]\n  }) \nclosest_sample &lt;- seoul_sobang |&gt; \n  slice(closest_index)\n\n이 정보를 이용해 샘플링 포인트와 최근린 소방서를 연결하는 라인을 생성하기 위한 함수를 작성한다.\n\nsnu_make_linestring_from_2points &lt;- function(source.point, target.point, target.id.var){\n  n &lt;- nrow(source.point)\n  line.list &lt;- list()\n  source_coord &lt;- st_coordinates(source.point)\n  target_coord &lt;- st_coordinates(target.point)\n  for (i in 1:n){\n    line.list[[i]] &lt;- st_sfc(st_linestring(rbind(source_coord[i, ], target_coord[i, ]))) # st_sfc를 씌우지 않으면 에러가 남!!!\n  }\n  final.line &lt;- do.call(rbind, line.list)\n  final.line &lt;- st_as_sf(st_sfc(final.line, crs = st_crs(seoul))) # 매우 중요\n  final.line &lt;- cbind(Name = target.point[[target.id.var]], final.line)\n} \n\n이 함수를 이용해 라인을 생성한다.\n\nclosest_sample_lines &lt;- snu_make_linestring_from_2points(network_sample, closest_sample, \"Name\")\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray80\") +\n  tm_shape(closest_sample_lines) + tm_lines(col = \"Name\", lwd = 2, legend.col.show = FALSE) + \n  tm_shape(seoul_sobang) + tm_dots(col = \"Name\", shape = 21, border.col = \"black\", size = 1, legend.show = FALSE) + \n  tm_shape(network_sample) + tm_dots(col = \"grey40\", size = 0.1) + \n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Closest Facilities: Network Allocation\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "GIS 모델링과 고급 GIS 분석",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>네트워크 분석</span>"
    ]
  },
  {
    "objectID": "sm_network.html#서비스영역분석",
    "href": "sm_network.html#서비스영역분석",
    "title": "\n23  네트워크 분석\n",
    "section": "\n23.6 서비스영역분석",
    "text": "23.6 서비스영역분석\n종로 소방서의 서비스영역을 분석한다. 서비스영역(isochrone)을 생성하기 위해 snNetwork 패키지를 활용한다.\n\ndevtools::install_github(\"JeremyGelb/spNetwork\")\nlibrary(spNetwork)\n\ncalc_isochrones 함수를 이용하여 2km, 5km, 10km 네트워크에 해당하는 서비스 영역을 생성한다.\n\niso_jongro &lt;- calc_isochrones(\n  lines = seoul_sn, start_points = jongro_st, dists = c(2, 5, 10), weight = \"LENGTH\") |&gt; \n  mutate(\n    fct_dist = fct(as.character(distance))\n  ) |&gt; \n  arrange(\n    desc(distance)\n  )\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray\") +\n  tm_shape(iso_jongro) + tm_lines(col = \"fct_dist\", lwd = 2, title.col = \"Distance (km)\", palette = c(\"1\" = \"#005f73\", \"5\" = \"#ca6702\", \"10\" = \"#9b2226\"))+\n  tm_shape(jongro_st) + tm_dots(col = \"black\", size = 1) + \n  tm_legend(legend.position = c(0.80, 0.05)) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Service Areas: Lines\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map\n\n\n\n\n\n\n\n서비스 영역에 대한 폴리곤을 생성한다. 여기서는 또 다른 패키지인 concaveman을 활용한다.\n\nlibrary(concaveman)\n\niso_jongro |&gt; \n  mutate(\n    iso_oid = str_c(point_id, distance, sep = \"_\")\n  ) -&gt; iso_jongro\n\npolygons &lt;- map(unique(iso_jongro$iso_oid), ~{\n  lines &lt;- subset(iso_jongro, iso_jongro$iso_oid == .x)\n  coords &lt;- st_coordinates(lines)\n  poly_coords &lt;- concaveman(points = coords, concavity = 3)\n  poly &lt;- st_polygon(list(poly_coords[, 1:2]))\n  return(poly)\n})\n\niso_sp &lt;- st_sf(iso_oid = unique(iso_jongro$iso_oid), distance = unique(iso_jongro$distance), geometry = polygons, crs = st_crs(iso_jongro)) \n\niso_sp |&gt; \n  mutate(\n    fct_dist = as.factor(distance)\n  ) |&gt; \n  arrange(\n    desc(distance)\n  ) -&gt; iso_sp\n\n# iso_jongro$iso_oid &lt;- paste(iso_jongro$point_id, iso_jongro$distance, sep = \"_\")\n# \n# polygons &lt;- lapply(unique(iso_jongro$iso_oid), function(oid){\n#   lines &lt;- subset(iso_jongro, iso_jongro$iso_oid == oid)\n#   coords &lt;- st_coordinates(lines)\n#   poly_coords &lt;- concaveman(points = coords, concavity = 3)\n#   poly &lt;- st_polygon(list(poly_coords[,1:2]))\n#   return(poly)\n# })\n# \n# iso_sp &lt;- st_sf(iso_oid = unique(iso_jongro$iso_oid), distance = unique(iso_jongro$distance), geometry = polygons, crs = st_crs(iso_jongro)) \n# \n# iso_sp$fct_dist &lt;- as.factor(iso_sp$distance)\n# iso_sp &lt;- iso_sp[order(-1*iso_sp$distance),]\n\n지도를 제작한다.\n\nmy_map &lt;- tm_shape(seoul, is.master = TRUE) + tm_polygons(col = \"gray98\", border.col = \"gray10\", lwd = 1) +\n  tm_shape(seoul_sn) + tm_lines(col = \"gray\") +\n  tm_shape(iso_sp) + tm_polygons(col = \"fct_dist\", title = \"Distance (km)\", palette = c(\"1\" = \"#005f73\", \"5\" = \"#ca6702\", \"10\" = \"#9b2226\"), alpha = 0.5, border.col = \"white\") +\n  tm_shape(jongro_st) + tm_dots(col = \"black\", size = 1) + \n  tm_legend(legend.position = c(0.80, 0.05)) +\n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04), \n            title = \"Service Areas: Polygons\", title.size = 1, \n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "GIS 모델링과 고급 GIS 분석",
      "<span class='chapter-number'>23</span>  <span class='chapter-title'>네트워크 분석</span>"
    ]
  },
  {
    "objectID": "raster_measurement.html#폴리곤의-형태",
    "href": "raster_measurement.html#폴리곤의-형태",
    "title": "\n16  측정\n",
    "section": "\n16.2 폴리곤의 형태",
    "text": "16.2 폴리곤의 형태\n콤펙트비(compactness ratio)를 다음의 수식에 의거해 계산한다.\n\\[\nS_1=A/(P^2/4\\pi)=4\\pi A/P^2\n\\]\n\\[\nS_2=(2\\pi \\sqrt{A/\\pi})/P=2\\sqrt{\\pi A}/P=3.545\\sqrt{A}/P\n\\]\n함수를 작성한다.\n\nsnu_poly_shape_index &lt;- function(poly.shp){\n  A &lt;- st_area(poly.shp)\n  P &lt;- st_length(st_cast(poly.shp, \"MULTILINESTRING\"))\n  S.1 &lt;- 4*pi*A/P^2\n  S.2 &lt;- sqrt(S.1)\n  poly.shp$S1 &lt;- as.numeric(S.1)\n  poly.shp$S2 &lt;- as.numeric(S.2)\n  poly.shp\n}\n\n서울시 구의 콤펙트비를 계산한다.\n\nseoul_gu &lt;- snu_poly_shape_index(seoul_gu)\nseoul_gu |&gt; slice_max(S1) \n\nSimple feature collection with 1 feature and 11 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 961989.7 ymin: 1952338 xmax: 966325.5 ymax: 1958028\nProjected CRS: KGD2002 / Unified CS\n  SGG1_CD SD_CD      SD_NM SG1_CD     SG1_NM SGG1_NM          SGG1_FNM\n1   11070    11 서울특별시     11 서울특별시  중랑구 서울특별시 중랑구\n       Eng_NM Chn_NM        S1        S2                       geometry\n1 Jungnang-gu 中浪區 0.6725585 0.8200967 POLYGON ((964125.5 1952433,...\n\nseoul_gu |&gt; slice_min(S1)\n\nSimple feature collection with 1 feature and 11 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 939273.8 ymin: 1941770 xmax: 947237.7 ymax: 1946700\nProjected CRS: KGD2002 / Unified CS\n  SGG1_CD SD_CD      SD_NM SG1_CD     SG1_NM SGG1_NM          SGG1_FNM  Eng_NM\n1   11170    11 서울특별시     11 서울특별시  구로구 서울특별시 구로구 Guro-gu\n  Chn_NM        S1        S2                       geometry\n1 九老區 0.2072557 0.4552534 POLYGON ((940771.4 1942203,...\n\n\n서울시 동의 콤펙트비를 계산한다.\n\nseoul_dong &lt;- snu_poly_shape_index(seoul_dong)\nseoul_dong |&gt; slice_max(S1) \n\nSimple feature collection with 1 feature and 17 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 964999.1 ymin: 1944822 xmax: 966120.8 ymax: 1945928\nProjected CRS: KGD2002 / Unified CS\n    EMD_ID SD_CD      SD_NM SG1_CD     SG1_NM SG2_CD     SG2_NM SGG1_CD SGG1_NM\n1 11240610    11 서울특별시     11 서울특별시     11 서울특별시   11240  송파구\n  SGG2_CD SGG2_NM EMD_NM_y                   EMD_FNM            Eng_NM  Chn_NM\n1   11240  송파구  송파1동 서울특별시 송파구 송파1동 Songpa 1(il)-dong 松坡1洞\n         S1        S2                       geometry\n1 0.8282855 0.9101019 POLYGON ((965536.1 1944822,...\n\nseoul_dong |&gt; slice_min(S1)\n\nSimple feature collection with 1 feature and 17 fields\nGeometry type: POLYGON\nDimension:     XY\nBounding box:  xmin: 959962.2 ymin: 1949952 xmax: 962352.3 ymax: 1951280\nProjected CRS: KGD2002 / Unified CS\n    EMD_ID SD_CD      SD_NM SG1_CD     SG1_NM SG2_CD     SG2_NM SGG1_CD SGG1_NM\n1 11040690    11 서울특별시     11 서울특별시     11 서울특별시   11040  성동구\n  SGG2_CD SGG2_NM EMD_NM_y                  EMD_FNM         Eng_NM Chn_NM\n1   11040  성동구   송정동 서울특별시 성동구 송정동 Songjeong-dong 松亭洞\n         S1        S2                       geometry\n1 0.2043469 0.4520475 POLYGON ((961792.8 1949976,...\n\n\n서울시 구의 콤펙트비 지도를 제작한다.\n\nmin.val &lt;- seoul_gu |&gt; pull(S1) |&gt; min() |&gt; format(digits = 3)\nmax.val &lt;- seoul_gu |&gt; pull(S1) |&gt; max() |&gt; format(digits = 3)\nmy_map &lt;- tm_shape(seoul_gu) + \n  tm_polygons(\n    col = \"S1\", palette = \"BuPu\", style = \"fixed\", breaks = c(0, 0.3, 0.4, 0.5, 0.6, 1),\n    labels = c(paste0(\"&lt; 0.3\", \" (Min. \", min.val, \")\"), \"0.3 ~ 0.4\", \"0.4 ~ 0.5\", \"0.5 ~ 0.6\", paste0(\"&gt;= 0.6\", \" (Max. \", max.val, \")\")),     title = \"Compactness\", legend.show = TRUE) +\n  tm_legend(legend.position = c(0.81, 0.03)) + \n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.13), \n            title = \"Compactness Ratio\", title.size = 1,\n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map \n\n\n\n\n\n\n\n서울시 동의 콤펙트비 지도를 제작한다.\n\nmin.val &lt;- seoul_dong |&gt; pull(S1) |&gt; min() |&gt; format(digits = 3)\nmax.val &lt;- seoul_dong |&gt; pull(S1) |&gt; max() |&gt; format(digits = 3)\nmy_map &lt;- tm_shape(seoul_dong) + \n  tm_polygons(\n    col = \"S1\", \n    palette = \"BuPu\", \n    style = \"fixed\", \n    breaks = c(0, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 1),\n    labels = c(paste0(\"&lt; 0.3\", \" (Min. \", min.val, \")\"), \"0.3 ~ 0.4\", \"0.4 ~ 0.5\", \"0.5 ~ 0.6\", \"0.6 ~ 0.7\", \"0.7 ~ 0.8\", paste0(\"&gt;= 0.8\", \" (Max. \", max.val, \")\")),     title = \"Compactness\", legend.show = TRUE) +\n  tm_shape(seoul_gu) + tm_borders(col = \"gray20\", lwd = 2) +\n  tm_legend(legend.position = c(0.81, 0.03)) + \n  tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.13), \n            title = \"Compactness Ratio\", title.size = 1,\n            title.position = c(\"LEFT\", \"TOP\")) + \n  tm_scale_bar(breaks = seq(0, 20, 5), color.dark = \"gray60\", position = c(0.03, 0.01))\nmy_map",
    "crumbs": [
      "래스터-기반 GIS 오퍼레이션",
      "<span class='chapter-number'>16</span>  <span class='chapter-title'>측정</span>"
    ]
  }
]