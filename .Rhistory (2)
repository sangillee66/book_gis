zones <- split(seoul_2020_pop$pop_t, partition)
zone_totals <- sapply(zones, sum)
# 인접성 위반 횟수 계산
penalty <- 0
for (i in 1:length(nb)) {
neighbors <- nb[[i]]  # i번 동의 이웃 동들
if (any(partition[i] != partition[neighbors])) {
penalty <- penalty + 1  # 인접한 동이 다른 구역에 있으면 패널티 증가
}
}
# 인구 표준편차 + 인접성 위반 패널티를 함께 고려
result <- sd(zone_totals) + penalty * 1000  # 패널티 가중치 조절 가능
print(result)
return(result)
}
# 3. 시뮬레이티드 어닐링 적용
N <- 10
initial_partition <- as.numeric(sample(1:N, nrow(seoul_2020_pop), replace = TRUE))  # 초기 구역 설정을 numeric 타입으로 변환
result <- GenSA(par = initial_partition, fn = objective_function, lower = rep(1, nrow(seoul_2020_pop)), upper = rep(N, nrow(seoul_2020_pop)), control = list(max.call = 5000, threshold.stop = 1e-5))
# 결과 출력
result$par <- round(result$par)
write_rds(result, "optimal_zone_1.rds")
seoul_2020_pop$zone <- result$par  # 최적화된 구역 할당 결과
set.seed(123)
# 목적함수: 인구 균등화 + 인접성 제약 조건 반영
objective_function <- function(partition) {
# 각 구역별로 인구 합계를 계산
zones <- split(seoul_2020_pop$pop_t, partition)
zone_totals <- sapply(zones, sum)
# 인접성 위반 횟수 계산
penalty <- 0
for (i in 1:length(nb)) {
neighbors <- nb[[i]]  # i번 동의 이웃 동들
if (any(partition[i] != partition[neighbors])) {
penalty <- penalty + 1  # 인접한 동이 다른 구역에 있으면 패널티 증가
}
}
# 인구 표준편차 + 인접성 위반 패널티를 함께 고려
result <- sd(zone_totals) + penalty * 1000  # 패널티 가중치 조절 가능
# print(result)
return(result)
}
# 3. 시뮬레이티드 어닐링 적용
N <- 10
initial_partition <- as.numeric(sample(1:N, nrow(seoul_2020_pop), replace = TRUE))  # 초기 구역 설정을 numeric 타입으로 변환
result <- GenSA(par = initial_partition, fn = objective_function, lower = rep(1, nrow(seoul_2020_pop)), upper = rep(N, nrow(seoul_2020_pop)), control = list(max.call = 5000, threshold.stop = 1e-5))
# 결과 출력
result$par <- round(result$par)
write_rds(result, "optimal_zone_1.rds")
seoul_2020_pop$zone <- result$par  # 최적화된 구역 할당 결과
set.seed(123)
# 목적함수: 인구 균등화 + 인접성 제약 조건 반영
objective_function <- function(partition) {
# 각 구역별로 인구 합계를 계산
zones <- split(seoul_2020_pop$pop_t, partition)
zone_totals <- sapply(zones, sum)
# 인접성 위반 횟수 계산
penalty <- 0
for (i in 1:length(nb)) {
neighbors <- nb[[i]]  # i번 동의 이웃 동들
if (any(partition[i] != partition[neighbors])) {
penalty <- penalty + 1  # 인접한 동이 다른 구역에 있으면 패널티 증가
}
}
# 인구 표준편차 + 인접성 위반 패널티를 함께 고려
result <- sd(zone_totals) + penalty * 1000  # 패널티 가중치 조절 가능
# print(result)
return(result)
}
# 3. 시뮬레이티드 어닐링 적용
N <- 10
initial_partition <- as.numeric(sample(1:N, nrow(seoul_2020_pop), replace = TRUE))  # 초기 구역 설정을 numeric 타입으로 변환
result <- GenSA(par = initial_partition, fn = objective_function, lower = rep(1, nrow(seoul_2020_pop)), upper = rep(N, nrow(seoul_2020_pop)), control = list(max.call = 10000, threshold.stop = 1e-5))
# 결과 출력
result$par <- round(result$par)
write_rds(result, "optimal_zone_1.rds")
seoul_2020_pop$zone <- result$par  # 최적화된 구역 할당 결과
#| results: hide
EMD_2020 <- st_read("D:/My R/Korean Administrative Areas/행정구역 셰이프 파일/2 Original Cleaning/2020_Census_Adj/EMD_2020_Census.shp", options = "ENCODING=CP949")
Pop_SDGGEMD_2020 <- read_excel("D:/My R/Korea Census Data Manipulation/1 Population Basic/DM_ADJ_Census_2020.xlsx", sheet = 1)
EMD_2020 <- EMD_2020 |>
mutate(
EMD_ID = as.numeric(EMD_ID)
)
EMD_2020_pop <- EMD_2020 |>
left_join(
Pop_SDGGEMD_2020, join_by(EMD_ID == Code)
)
seoul_2020_pop <- EMD_2020_pop |>
filter(
SD_NM == "서울특별시"
)
optimal_res <- read_rds(optimal_zone_1.rds)
optimal_res <- read_rds("optimal_zone_1.rds")
View(optimal_res)
optimal_res <- read_rds("optimal_zone_1.rds")
seoul_2020_pop$zone <- result$par
View(EMD_2020_pop)
View(seoul_2020_pop)
seoul_zone_10 <- seoul_2020_pop |>
group_by(zone) |>
mutate(
geometry = st_union(geometry),
pop_total = sum(pop_t)
)
qtm(seoul_zone_10)
View(seoul_2020_pop)
View(seoul_2020_pop)
seoul_zone_10 <- seoul_2020_pop |>
group_by(zone) |>
mutate(
geometry = st_union(geometry)
)
qtm(seoul_zone_10)
qtm(seoul_2020_pop)
seoul_zone_10 <- seoul_2020_pop |>
group_by(as.character(zone)) |>
mutate(
geometry = st_union(geometry),
pop_total = sum(pop_t)
)
qtm(seoul_zone_10)
optimal_res <- read_rds("optimal_zone_1.rds")
seoul_2020_pop$zone <- as.character(result$par)
seoul_zone_10 <- seoul_2020_pop |>
group_by(zone) |>
mutate(
geometry = st_union(geometry),
pop_total = sum(pop_t)
)
qtm(seoul_zone_10)
View(seoul_2020_pop)
optimal_res <- read_rds("optimal_zone_1.rds")
seoul_2020_pop$zone <- result$par
utd.spatial.random.aggregation <- function (nhbr, m.region)
{
# purpose: Generating a swm (gal format) of a spatial random aggregation from a binary swm of a polygon layer
# Arguments:
#   nhbr: a swm (gal formal) of an input polygon layer
#   m.region: the target number of polygons
# Fuction called:
#   utd.rank.out (from Monghyeon)
##### First part: Extracting the an ggregation info (will be stored in sra.res) ragarding which areal units are aggregated to any seed areal unit
# Randomly select a set of seed units (m.region)
n <- max(nhbr[,1])
seed.num <- sample(1:n, m.region)
# Define two final data frames; the length of sra.res will increase, while the length of nhbr.res will decrease
sra.res <- data.frame(seed.num, seed.num)
nhbr.res <- nhbr
# Delete entries in nhbr.res related to the seed units
for (i in 1:m.region)
{
a <- seed.num[i]
nhbr.res <- nhbr.res[!nhbr.res[,2]==a,]
}
# Delete entries in sra.res and add entries in sra.res while looping
repeat
{
for (j in 1:m.region)
{
bb <- seed.num[j]
col.set <- vector()
nhbr.id <- sra.res[,2][sra.res[,1]==bb]
for (dd in 1:length(nhbr.id))
{
nhbr.id.i <- nhbr.res[,2][nhbr.res[,1]==nhbr.id[dd]]
col.set <- c(col.set, nhbr.id.i)
}
if (length(col.set)!=0)
{
col.selected <- sample(c(unique(col.set), bb), 1)
if (col.selected!=bb)
{
sra.res <- rbind(sra.res, c(bb, col.selected))
nhbr.res <- nhbr.res[!nhbr.res[,2]==col.selected,]
}
}
if (length(nhbr.res[,1])==0) break
}
if (length(nhbr.res[,1])==0) break
}
# Obtain the final sra.res
colnames(sra.res) <- c("seed.id", "agg.id")
sra.res <- sra.res[order(sra.res$seed.id, sra.res$agg.id),]
##### Second part: Constructing a swm on the basis of the aggregation info (will be stored in new.swm.1)
for (kk in 1:m.region)
{
nhbr.id.new <- sra.res[,2][sra.res[,1]==seed.num[kk]]
nhbr.new.num <- length(nhbr.id.new)
if (nhbr.new.num==0) {next}
new.nhbr.vec <- vector()
for (mm in 1:nhbr.new.num)
{
nhbr.id.old <- nhbr[,1][nhbr[,2]==nhbr.id.new[mm]]
nhbr.old.num <- length(nhbr.id.old)
if (nhbr.old.num==0) {next}
for (nn in 1:nhbr.old.num)
{
new.nhbr.id <- sra.res[,1][sra.res[,2]==nhbr.id.old[nn]]
new.nhbr.vec <- c(new.nhbr.vec, new.nhbr.id)
}
}
new.nhbr.vec <- unique(new.nhbr.vec)
length.vec <- length(new.nhbr.vec)
if (kk==1)
{new.nhbr.res <- data.frame(row.id=rep(seed.num[kk], length.vec), col.id=new.nhbr.vec)}
else
{new.nhbr.res <- rbind(new.nhbr.res, cbind(row.id=rep(seed.num[kk], length.vec), col.id=new.nhbr.vec))}
}
new.nhbr.res <- new.nhbr.res[!new.nhbr.res[,1]==new.nhbr.res[,2],]
new.nhbr.res <- cbind(new.nhbr.res, weights=rep(1,length(new.nhbr.res[,1])))
new.nhbr.res <- new.nhbr.res[order(new.nhbr.res$row.id, new.nhbr.res$col.id),]
##### Third part: Updating the new swm with new IDs (will be stored in new.swm.2)
utd.rank.out <- function(a.vec)
{
a.vec <- as.vector(a.vec)
A <- as.data.frame(cbind(1:length(a.vec),a.vec))
colnames(A) <- c("id", "value")
B <- as.data.frame(cbind(unique(a.vec), rank(unique(a.vec))))
colnames(B) <- c("value", "rank")
res <- merge(A, B, by="value")
res[order(res$id),]$rank
}
new.new.nhbr.res.1 <- as.vector(utd.rank.out(new.nhbr.res[,1]))
new.new.nhbr.res.2 <- as.vector(utd.rank.out(new.nhbr.res[,2]))
new.new.nhbr.res <- data.frame(row.id=new.new.nhbr.res.1, col.id=new.new.nhbr.res.2, weights=rep(1,length(new.nhbr.res[,1])))
new.new.nhbr.res <- new.new.nhbr.res[order(new.new.nhbr.res$row.id, new.new.nhbr.res$col.id),]
colnames(new.nhbr.res) <- c("from", "to", "weights")
colnames(new.new.nhbr.res) <- c("from", "to", "weights")
all.res <- list(sra=sra.res, new.swm.1=new.nhbr.res, new.swm.2=new.new.nhbr.res)
}
seoul_dong_nb <- poly2nb(seoul_dong, queen=FALSE)
seoul_dong_sw <- nb2listw(seoul_dong_nb, style="B")
seoul_dong_sn <- listw2sn(seoul_dong_sw)
seoul_sra_25_1 <- utd.spatial.random.aggregation(seoul_dong_sn, 25)
seoul_sra_25_1 <- seoul_sra_25_1$sra
seoul_dong <- seoul_dong |>
mutate(
id = row_number()
)
seoul_dong_1 <- seoul_dong |>
left_join(seoul_sra_25_1, join_by(id == agg.id))
View(seoul_dong_1)
View(seoul_2020_pop)
unique(seoul_2020_pop$zone)
View(seoul_zone_10)
seoul_zone_10 <- seoul_2020_pop |>
group_by(zone) |>
summarize(
geometry = st_union(geometry),
pop_total = sum(pop_t),
.groups = 'drop'
)
qtm(seoul_zone_10)
seoul_zone_10 <- seoul_2020_pop |>
group_by(zone) |>
mutate(
geometry = st_union(geometry),
pop_total = sum(pop_t),
.groups = 'drop'
)
qtm(seoul_zone_10)
seoul_zone_10 <- seoul_2020_pop |>
group_by(zone) |>
summarize(
geometry = st_union(geometry),
pop_total = sum(pop_t),
.groups = 'drop'
)
qtm(seoul_zone_10)
qtm(seoul_zone_10, col = zone)
qtm(seoul_zone_10, col = "zone")
qtm(seoul_zone_10, color = "zone")
tm_shape(seoul_zone_10) + tm_polygons(col = "zone")
tm_shape(seoul_zone_10) + tm_polygons(col = "zone", type = "cat")
View(seoul_zone_10)
tm_shape(seoul_zone_10) + tm_polygons(col = "zone", style = "cat")
seoul_zone_10 <- seoul_2020_pop |>
group_by(zone) |>
summarize(
geometry = st_union(geometry),
pop_total = sum(pop_t),
.groups = 'drop'
)
seoul_zone_10$zone <- as.character(seoul_zone_10$zone)
tm_shape(seoul_zone_10) + tm_polygons(col = "zone", style = "cat")
set.seed(123)
# 목적함수: 인구 균등화 + 인접성 제약 조건 반영
objective_function <- function(partition) {
# 각 구역별로 인구 합계를 계산
zones <- split(seoul_2020_pop$pop_t, partition)
zone_totals <- sapply(zones, sum)
# 인접성 위반 횟수 계산
penalty <- 0
for (i in 1:length(nb)) {
neighbors <- nb[[i]]  # i번 동의 이웃 동들
if (any(partition[i] != partition[neighbors])) {
penalty <- penalty + 1  # 인접한 동이 다른 구역에 있으면 패널티 증가
}
}
# 인구 표준편차 + 인접성 위반 패널티를 함께 고려
result <- sd(zone_totals) + penalty * 1000  # 패널티 가중치 조절 가능
# print(result)
return(result)
}
# 3. 시뮬레이티드 어닐링 적용
N <- 10
initial_partition <- as.numeric(sample(1:N, nrow(seoul_2020_pop), replace = TRUE))  # 초기 구역 설정을 numeric 타입으로 변환
result <- GenSA(par = initial_partition, fn = objective_function, lower = rep(1, nrow(seoul_2020_pop)), upper = rep(N, nrow(seoul_2020_pop)), control = list(max.call = 100000, threshold.stop = 1e-5))
# 결과 출력
result$par <- round(result$par)
write_rds(result, "optimal_zone_1.rds")
# seoul_2020_pop$zone <- result$par  # 최적화된 구역 할당 결과
optimal_res <- read_rds("optimal_zone_1.rds")
seoul_2020_pop$zone <- result$par
seoul_zone_10 <- seoul_2020_pop |>
group_by(zone) |>
summarize(
geometry = st_union(geometry),
pop_total = sum(pop_t),
.groups = 'drop'
)
seoul_zone_10$zone <- as.character(seoul_zone_10$zone)
tm_shape(seoul_zone_10) + tm_polygons(col = "zone", style = "cat")
View(seoul_dong_1)
seoul_dong_sra_25_1 <- seoul_dong_1 |>
group_by(seed.id) |>
summarize(
geometry = st_union(geometry)
)
View(seoul_dong_sra_25_1)
my_map <- tm_shape(seoul_gu) + tm_polygons(col = "SGG1_NM", border.col = NULL, legend.show = FALSE) +
tm_shape(seoul_dong_sra_25_1) + tm_borders(lwd = 1.5, col = "gray20") +
tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) +
tm_scale_bar(breaks = seq(0, 20, 4), color.dark = "gray60", position = c(0.03, 0.01))
my_map
#| echo: false
#| output: false
my_map <- tm_shape(seoul_gu) + tm_polygons(col = "SGG1_NM", border.col = NULL, legend.show = FALSE) +
tm_shape(seoul_dong_sra_25_1) + tm_borders(lwd = 3, col = "gray20") +
tm_layout(inner.margins = c(0.05, 0.04, 0.04, 0.04)) +
tm_scale_bar(breaks = seq(0, 20, 5), text.size = 0.6, color.dark = "gray60", position = c(0.03, 0.01)) +
tm_credits(text = "SANG-IL LEE, Geography Education at SNU, 2024", size = 0.8, position = c(0.76, 0.01))
my_map
my.path.name <- "D:/My Classes/2024년 2학기/지리정보체계와 지리교육/이미지/"
my.file.name <- paste0(my.path.name, "벡터_재분류_합역1", ".jpg")
tmap_save(my_map, filename = my.file.name, height = 12.1, dpi = 600)
seoul_dong_sra_25_1 <- seoul_dong_1 |>
group_by(seed.id) |>
summarize(
geometry = st_union(geometry),
.groups = "drop"
)
my_map <- tm_shape(seoul_gu) + tm_polygons(col = "SGG1_NM", border.col = NULL, legend.show = FALSE) +
tm_shape(seoul_dong_sra_25_1) + tm_borders(lwd = 1.5, col = "gray20") +
tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) +
tm_scale_bar(breaks = seq(0, 20, 4), color.dark = "gray60", position = c(0.03, 0.01))
my_map
#| echo: false
#| output: false
my_map <- tm_shape(seoul_gu) + tm_polygons(col = "SGG1_NM", border.col = NULL, legend.show = FALSE) +
tm_shape(seoul_dong_sra_25_1) + tm_borders(lwd = 3, col = "gray20") +
tm_layout(inner.margins = c(0.05, 0.04, 0.04, 0.04)) +
tm_scale_bar(breaks = seq(0, 20, 5), text.size = 0.6, color.dark = "gray60", position = c(0.03, 0.01)) +
tm_credits(text = "SANG-IL LEE, Geography Education at SNU, 2024", size = 0.8, position = c(0.76, 0.01))
my_map
my.path.name <- "D:/My Classes/2024년 2학기/지리정보체계와 지리교육/이미지/"
my.file.name <- paste0(my.path.name, "벡터_재분류_합역1", ".jpg")
tmap_save(my_map, filename = my.file.name, height = 12.1, dpi = 600)
seoul_sra_25_2 <- utd.spatial.random.aggregation(seoul_dong_sn, 25)
seoul_sra_25_2 <- seoul_sra_25_2$sra
seoul_dong_2 <- seoul_dong |>
left_join(seoul_sra_25_2, join_by(id == agg.id))
seoul_dong_sra_25_2 <- seoul_dong_2 |>
group_by(seed.id) |>
summarize(
geometry = st_union(geometry),
.groups = "drop"
)
my_map <- tm_shape(seoul_gu) + tm_polygons(col = "SGG1_NM", border.col = NULL, legend.show = FALSE) +
tm_shape(seoul_dong_sra_25_2) + tm_borders(lwd = 1.5, col = "gray20") +
tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) +
tm_scale_bar(breaks = seq(0, 20, 4), color.dark = "gray60", position = c(0.03, 0.01))
my_map
#| echo: false
#| output: false
my_map <- tm_shape(seoul_gu) + tm_polygons(col = "SGG1_NM", border.col = NULL, legend.show = FALSE) +
tm_shape(seoul_dong_sra_25_2) + tm_borders(lwd = 3, col = "gray20") +
tm_layout(inner.margins = c(0.05, 0.04, 0.04, 0.04)) +
tm_scale_bar(breaks = seq(0, 20, 5), text.size = 0.6, color.dark = "gray60", position = c(0.03, 0.01)) +
tm_credits(text = "SANG-IL LEE, Geography Education at SNU, 2024", size = 0.8, position = c(0.76, 0.01))
my_map
my.path.name <- "D:/My Classes/2024년 2학기/지리정보체계와 지리교육/이미지/"
my.file.name <- paste0(my.path.name, "벡터_재분류_합역2", ".jpg")
tmap_save(my_map, filename = my.file.name, height = 12.1, dpi = 600)
seoul_sra_25_3 <- utd.spatial.random.aggregation(seoul_dong_sn, 25)
seoul_sra_25_3 <- seoul_sra_25_3$sra
seoul_dong_3 <- seoul_dong |>
left_join(seoul_sra_25_3, join_by(id == agg.id))
seoul_dong_sra_25_3 <- seoul_dong_3 |>
group_by(seed.id) |>
summarize(
geometry = st_union(geometry),
.groups = "drop"
)
my_map <- tm_shape(seoul_gu) + tm_polygons(col = "SGG1_NM", border.col = NULL, legend.show = FALSE) +
tm_shape(seoul_dong_sra_25_3) + tm_borders(lwd = 1.5, col = "gray20") +
tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) +
tm_scale_bar(breaks = seq(0, 20, 4), color.dark = "gray60", position = c(0.03, 0.01))
my_map
#| echo: false
#| output: false
my_map <- tm_shape(seoul_gu) + tm_polygons(col = "SGG1_NM", border.col = NULL, legend.show = FALSE) +
tm_shape(seoul_dong_sra_25_3) + tm_borders(lwd = 3, col = "gray20") +
tm_layout(inner.margins = c(0.05, 0.04, 0.04, 0.04)) +
tm_scale_bar(breaks = seq(0, 20, 5), text.size = 0.6, color.dark = "gray60", position = c(0.03, 0.01)) +
tm_credits(text = "SANG-IL LEE, Geography Education at SNU, 2024", size = 0.8, position = c(0.76, 0.01))
my_map
my.path.name <- "D:/My Classes/2024년 2학기/지리정보체계와 지리교육/이미지/"
my.file.name <- paste0(my.path.name, "벡터_재분류_합역3", ".jpg")
tmap_save(my_map, filename = my.file.name, height = 12.1, dpi = 600)
seoul_dong_nb <- poly2nb(seoul_dong, queen=FALSE)
seoul_dong_sw <- nb2listw(seoul_dong_nb, style="B")
seoul_dong_sn <- listw2sn(seoul_dong_sw)
seoul_sra_25_4 <- utd.spatial.random.aggregation(seoul_dong_sn, 25)
seoul_sra_25_4 <- seoul_sra_25_4$sra
seoul_dong_4 <- seoul_dong |>
left_join(seoul_sra_25_4, join_by(id == agg.id))
seoul_dong_sra_25_4 <- seoul_dong_4 |>
group_by(seed.id) |>
summarize(
geometry = st_union(geometry),
.groups = "drop"
)
my_map <- tm_shape(seoul_gu) + tm_polygons(col = "SGG1_NM", border.col = NULL, legend.show = FALSE) +
tm_shape(seoul_dong_sra_25_4) + tm_borders(lwd = 1.5, col = "gray20") +
tm_layout(inner.margins = c(0.06, 0.04, 0.04, 0.04)) +
tm_scale_bar(breaks = seq(0, 20, 4), color.dark = "gray60", position = c(0.03, 0.01))
my_map
#| echo: false
#| output: false
my_map <- tm_shape(seoul_gu) + tm_polygons(col = "SGG1_NM", border.col = NULL, legend.show = FALSE) +
tm_shape(seoul_dong_sra_25_4) + tm_borders(lwd = 3, col = "gray20") +
tm_layout(inner.margins = c(0.05, 0.04, 0.04, 0.04)) +
tm_scale_bar(breaks = seq(0, 20, 5), text.size = 0.6, color.dark = "gray60", position = c(0.03, 0.01)) +
tm_credits(text = "SANG-IL LEE, Geography Education at SNU, 2024", size = 0.8, position = c(0.76, 0.01))
my_map
my.path.name <- "D:/My Classes/2024년 2학기/지리정보체계와 지리교육/이미지/"
my.file.name <- paste0(my.path.name, "벡터_재분류_합역4", ".jpg")
tmap_save(my_map, filename = my.file.name, height = 12.1, dpi = 600)
set.seed(123)
# 목적함수: 인구 균등화 + 인접성 제약 조건 반영
objective_function <- function(partition) {
# 각 구역별로 인구 합계를 계산
zones <- split(seoul_2020_pop$pop_t, partition)
zone_totals <- sapply(zones, sum)
# 인접성 위반 횟수 계산
penalty <- 0
for (i in 1:length(nb)) {
neighbors <- nb[[i]]  # i번 동의 이웃 동들
if (any(partition[i] != partition[neighbors])) {
penalty <- penalty + 1  # 인접한 동이 다른 구역에 있으면 패널티 증가
}
}
# 인구 표준편차 + 인접성 위반 패널티를 함께 고려
result <- sd(zone_totals) + penalty * 10000  # 패널티 가중치 조절 가능
# print(result)
return(result)
}
# 3. 시뮬레이티드 어닐링 적용
N <- 10
initial_partition <- as.numeric(sample(1:N, nrow(seoul_2020_pop), replace = TRUE))  # 초기 구역 설정을 numeric 타입으로 변환
result <- GenSA(par = initial_partition, fn = objective_function, lower = rep(1, nrow(seoul_2020_pop)), upper = rep(N, nrow(seoul_2020_pop)), control = list(max.call = 1000000, threshold.stop = 1e-5))
set.seed(123)
# 목적함수: 인구 균등화 + 인접성 제약 조건 반영
objective_function <- function(partition) {
# 각 구역별로 인구 합계를 계산
zones <- split(seoul_2020_pop$pop_t, partition)
zone_totals <- sapply(zones, sum)
# 인접성 위반 횟수 계산
penalty <- 0
for (i in 1:length(nb)) {
neighbors <- nb[[i]]  # i번 동의 이웃 동들
if (any(partition[i] != partition[neighbors])) {
penalty <- penalty + 1  # 인접한 동이 다른 구역에 있으면 패널티 증가
}
}
# 인구 표준편차 + 인접성 위반 패널티를 함께 고려
result <- sd(zone_totals) + penalty * 10000  # 패널티 가중치 조절 가능
# print(result)
return(result)
}
# 3. 시뮬레이티드 어닐링 적용
N <- 10
initial_partition <- as.numeric(sample(1:N, nrow(seoul_2020_pop), replace = TRUE))  # 초기 구역 설정을 numeric 타입으로 변환
result <- GenSA(par = initial_partition, fn = objective_function, lower = rep(1, nrow(seoul_2020_pop)), upper = rep(N, nrow(seoul_2020_pop)), control = list(max.call = 1000000, threshold.stop = 1e-5))
# 결과 출력
result$par <- round(result$par)
write_rds(result, "optimal_zone_1.rds")
# seoul_2020_pop$zone <- result$par  # 최적화된 구역 할당 결과
optimal_res <- read_rds("optimal_zone_1.rds")
seoul_2020_pop$zone <- result$par
seoul_zone_10 <- seoul_2020_pop |>
group_by(zone) |>
summarize(
geometry = st_union(geometry),
pop_total = sum(pop_t),
.groups = 'drop'
)
seoul_zone_10$zone <- as.character(seoul_zone_10$zone)
tm_shape(seoul_zone_10) + tm_polygons(col = "zone", style = "cat")
View(seoul_zone_10)
